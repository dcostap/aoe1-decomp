// Auto-generated decompiler unit: zone_map.cpp.decomp
// SourceMap: C:/msdev/work/age1_x1/zone_map.cpp
#include "../include/common.h"

// Offset: 0x00546720
uchar zone_pop(Zone_Queue** param_1, Zone_Queue** param_2, long* param_3, long* param_4) {
    // --- Ghidra decompiler output ---
    // 
    // /* unsigned char __cdecl zone_pop(struct Zone_Queue * *,struct Zone_Queue * *,long &,long &) */
    // 
    // uchar __cdecl zone_pop(Zone_Queue **param_1,Zone_Queue **param_2,long *param_3,long *param_4)
    // 
    // {
    //   Zone_Queue *pZVar1;
    //   
    //   pZVar1 = *param_1;
    //   if (pZVar1 == (Zone_Queue *)0x0) {
    //     return '\0';
    //   }
    //   *param_3 = pZVar1->x;
    //   *param_4 = pZVar1->y;
    //   *param_1 = pZVar1->next;
    //   free(pZVar1);
    //   if (*param_1 == (Zone_Queue *)0x0) {
    //     *param_2 = (Zone_Queue *)0x0;
    //   }
    //   return '\x01';
    // }
    // 
    // 
}

// Offset: 0x00546770
void zone_push(Zone_Queue** param_1, Zone_Queue** param_2, long param_3, long param_4) {
    // --- Ghidra decompiler output ---
    // 
    // /* void __cdecl zone_push(struct Zone_Queue * *,struct Zone_Queue * *,long,long) */
    // 
    // void __cdecl zone_push(Zone_Queue **param_1,Zone_Queue **param_2,long param_3,long param_4)
    // 
    // {
    //   Zone_Queue *pZVar1;
    //   
    //   pZVar1 = (Zone_Queue *)calloc(1,0xc);
    //   if (*param_2 != (Zone_Queue *)0x0) {
    //     (*param_2)->next = pZVar1;
    //   }
    //   pZVar1->x = param_3;
    //   pZVar1->y = param_4;
    //   *param_2 = pZVar1;
    //   if (*param_1 == (Zone_Queue *)0x0) {
    //     *param_1 = pZVar1;
    //   }
    //   return;
    // }
    // 
    // 
}

// Offset: 0x005467B0
undefined RGE_Zone_Map(RGE_Zone_Map* this_, int param_2, RGE_Map* param_3) {
    // --- Ghidra decompiler output ---
    // 
    // /* public: __thiscall RGE_Zone_Map::RGE_Zone_Map(int,class RGE_Map *) */
    // 
    // RGE_Zone_Map * __thiscall
    // RGE_Zone_Map::RGE_Zone_Map(RGE_Zone_Map *this,int param_1,RGE_Map *param_2)
    // 
    // {
    //   long *plVar1;
    //   uchar *puVar2;
    //   uchar **ppuVar3;
    //   int iVar4;
    //   float *pfVar5;
    //   RGE_Map *pRVar6;
    //   
    //   this->map = param_2;
    //   puVar2 = (uchar *)calloc(param_2->map_width * param_2->map_height,1);
    //   this->zone_map = puVar2;
    //   ppuVar3 = (uchar **)calloc(this->map->map_height,4);
    //   pRVar6 = this->map;
    //   this->zone_map_rows = ppuVar3;
    //   iVar4 = 0;
    //   if (0 < pRVar6->map_height) {
    //     do {
    //       this->zone_map_rows[iVar4] = this->zone_map + pRVar6->map_width * iVar4;
    //       pRVar6 = this->map;
    //       iVar4 = iVar4 + 1;
    //     } while (iVar4 < pRVar6->map_height);
    //   }
    //   rge_read(param_1,this->zone_info,0xff);
    //   rge_read(param_1,this,0x3fc);
    //   rge_read(param_1,this->zone_map,this->map->map_height * this->map->map_width);
    //   plVar1 = &this->terrain_passability_rules_num;
    //   rge_read(param_1,plVar1,4);
    //   if (0 < *plVar1) {
    //     pfVar5 = (float *)calloc(*plVar1,4);
    //     this->terrain_passability_rules = pfVar5;
    //     rge_read(param_1,pfVar5,*plVar1 << 2);
    //     return this;
    //   }
    //   this->terrain_passability_rules = (float *)0x0;
    //   return this;
    // }
    // 
    // 
}

// Offset: 0x005468C0
undefined RGE_Zone_Map(RGE_Zone_Map* this_, RGE_Map* param_2, float* param_3, long param_4) {
    // --- Ghidra decompiler output ---
    // 
    // /* public: __thiscall RGE_Zone_Map::RGE_Zone_Map(class RGE_Map *,float *,long) */
    // 
    // RGE_Zone_Map * __thiscall
    // RGE_Zone_Map::RGE_Zone_Map(RGE_Zone_Map *this,RGE_Map *param_1,float *param_2,long param_3)
    // 
    // {
    //   uchar *puVar1;
    //   uchar **ppuVar2;
    //   int iVar3;
    //   float *pfVar4;
    //   uint uVar5;
    //   uint uVar6;
    //   RGE_Map *pRVar7;
    //   RGE_Zone_Map *pRVar8;
    //   
    //   this->map = param_1;
    //   puVar1 = (uchar *)calloc(param_1->map_height * param_1->map_width,1);
    //   this->zone_map = puVar1;
    //   uVar5 = this->map->map_height * this->map->map_width;
    //   for (uVar6 = uVar5 >> 2; uVar6 != 0; uVar6 = uVar6 - 1) {
    //     puVar1[0] = 0xff;
    //     puVar1[1] = 0xff;
    //     puVar1[2] = 0xff;
    //     puVar1[3] = 0xff;
    //     puVar1 = puVar1 + 4;
    //   }
    //   for (uVar5 = uVar5 & 3; uVar5 != 0; uVar5 = uVar5 - 1) {
    //     *puVar1 = 0xff;
    //     puVar1 = puVar1 + 1;
    //   }
    //   ppuVar2 = (uchar **)calloc(this->map->map_height,4);
    //   pRVar7 = this->map;
    //   this->zone_map_rows = ppuVar2;
    //   iVar3 = 0;
    //   if (0 < pRVar7->map_height) {
    //     do {
    //       this->zone_map_rows[iVar3] = this->zone_map + pRVar7->map_width * iVar3;
    //       pRVar7 = this->map;
    //       iVar3 = iVar3 + 1;
    //     } while (iVar3 < pRVar7->map_height);
    //   }
    //   iVar3 = 0;
    //   pRVar8 = this;
    //   do {
    //     this->zone_info[iVar3] = 0xff;
    //     pRVar8->numberTilesInZoneValue[0] = 0;
    //     iVar3 = iVar3 + 1;
    //     pRVar8 = (RGE_Zone_Map *)(pRVar8->numberTilesInZoneValue + 1);
    //   } while (iVar3 < 0xff);
    //   this->terrain_passability_rules_num = param_3;
    //   pfVar4 = (float *)calloc(param_3,4);
    //   this->terrain_passability_rules = pfVar4;
    //   for (uVar6 = this->terrain_passability_rules_num & 0x3fffffff; uVar6 != 0; uVar6 = uVar6 - 1) {
    //     *pfVar4 = *param_2;
    //     param_2 = param_2 + 1;
    //     pfVar4 = pfVar4 + 1;
    //   }
    //   for (iVar3 = 0; iVar3 != 0; iVar3 = iVar3 + -1) {
    //     *(undefined1 *)pfVar4 = *(undefined1 *)param_2;
    //     param_2 = (float *)((int)param_2 + 1);
    //     pfVar4 = (float *)((int)pfVar4 + 1);
    //   }
    //   do_zone_map(this);
    //   return this;
    // }
    // 
    // 
}

// Offset: 0x005469C0
void RGE_Zone_Map(RGE_Zone_Map* this_) {
    // --- Ghidra decompiler output ---
    // 
    // /* public: __thiscall RGE_Zone_Map::~RGE_Zone_Map(void) */
    // 
    // void __thiscall RGE_Zone_Map::~RGE_Zone_Map(RGE_Zone_Map *this)
    // 
    // {
    //   free(this->zone_map);
    //   free(this->zone_map_rows);
    //   free(this->terrain_passability_rules);
    //   return;
    // }
    // 
    // 
}

// Offset: 0x00546A00
void save(RGE_Zone_Map* this_, int param_2) {
    // --- Ghidra decompiler output ---
    // 
    // /* public: void __thiscall RGE_Zone_Map::save(int) */
    // 
    // void __thiscall RGE_Zone_Map::save(RGE_Zone_Map *this,int param_1)
    // 
    // {
    //   int iVar1;
    //   
    //   rge_write(param_1,this->zone_info,0xff);
    //   rge_write(param_1,this,0x3fc);
    //   rge_write(param_1,this->zone_map,this->map->map_height * this->map->map_width);
    //   rge_write(param_1,&this->terrain_passability_rules_num,4);
    //   iVar1 = this->terrain_passability_rules_num;
    //   if (0 < iVar1) {
    //     rge_write(param_1,this->terrain_passability_rules,iVar1 * 4);
    //   }
    //   return;
    // }
    // 
    // 
}

// Offset: 0x00546A90
uchar do_zone_map(RGE_Zone_Map* this_) {
    // --- Ghidra decompiler output ---
    // 
    // /* public: unsigned char __thiscall RGE_Zone_Map::do_zone_map(void) */
    // 
    // uchar __thiscall RGE_Zone_Map::do_zone_map(RGE_Zone_Map *this)
    // 
    // {
    //   float fVar1;
    //   int iVar2;
    //   int iVar3;
    //   int iVar4;
    //   int iVar5;
    //   int iVar6;
    //   int iVar7;
    //   uchar *puVar8;
    //   long y;
    //   uchar group;
    //   long map_width;
    //   long map_height;
    //   
    //   iVar6 = 0;
    //   iVar2 = this->map->map_width;
    //   iVar3 = this->map->map_height;
    //   puVar8 = this->zone_info;
    //   for (iVar5 = 0x3f; iVar5 != 0; iVar5 = iVar5 + -1) {
    //     puVar8[0] = 0xff;
    //     puVar8[1] = 0xff;
    //     puVar8[2] = 0xff;
    //     puVar8[3] = 0xff;
    //     puVar8 = puVar8 + 4;
    //   }
    //   puVar8[0] = 0xff;
    //   puVar8[1] = 0xff;
    //   iVar5 = 0;
    //   puVar8[2] = 0xff;
    //   if (0 < iVar2) {
    //     do {
    //       iVar7 = 0;
    //       if (0 < iVar3) {
    //         do {
    //           iVar4 = iVar7 + 1;
    //           this->zone_map_rows[iVar5][iVar7] = 0xff;
    //           iVar7 = iVar4;
    //         } while (iVar4 < iVar3);
    //       }
    //       iVar5 = iVar5 + 1;
    //     } while (iVar5 < iVar2);
    //   }
    //   iVar5 = 0;
    //   _group = 0;
    //   if (0 < iVar2) {
    //     do {
    //       iVar7 = 0;
    //       if (0 < iVar3) {
    //         y = 0;
    //         do {
    //           if (*(char *)(iVar7 + *(int *)((int)this->zone_map_rows + iVar5)) == -1) {
    //             if (0xfe < iVar6) {
    //               iVar6 = 0;
    //             }
    //             fVar1 = this->terrain_passability_rules
    //                     [*(byte *)(*(int *)((int)this->map->map_row_offset + iVar5) + 5 + y) & 0x1f];
    //             *(uchar *)(iVar7 + *(int *)((int)this->zone_map_rows + iVar5)) = (uchar)iVar6;
    //             do_zone_map_area(this,iVar7,_group,0.0 < fVar1,(uchar)iVar6);
    //             iVar6 = iVar6 + 1;
    //           }
    //           iVar7 = iVar7 + 1;
    //           y = y + 0x18;
    //         } while (iVar7 < iVar3);
    //       }
    //       _group = _group + 1;
    //       iVar5 = iVar5 + 4;
    //     } while (_group < iVar2);
    //   }
    //   return '\x01';
    // }
    // 
    // 
}

// Offset: 0x00546BB0
void do_zone_map_area(RGE_Zone_Map* this_, long param_2, long param_3, uchar param_4, uchar param_5) {
    // --- Ghidra decompiler output ---
    // 
    // /* WARNING: Variable defined which should be unmapped: zone_end */
    // /* private: void __thiscall RGE_Zone_Map::do_zone_map_area(long,long,unsigned char,unsigned char) */
    // 
    // void __thiscall
    // RGE_Zone_Map::do_zone_map_area
    //           (RGE_Zone_Map *this,long param_1,long param_2,uchar param_3,uchar param_4)
    // 
    // {
    //   uchar uVar1;
    //   uchar uVar2;
    //   undefined3 in_stack_0000000d;
    //   Zone_Queue *zone_end;
    //   Zone_Queue *zone_queue;
    //   Zone_Queue *local_c;
    //   int local_8;
    //   int local_4;
    //   
    //   uVar1 = param_4;
    //   local_c = (Zone_Queue *)0x0;
    //   zone_queue = (Zone_Queue *)0x0;
    //   local_8 = this->map->map_width + -1;
    //   local_4 = this->map->map_height + -1;
    //   do {
    //     if (0 < param_1) {
    //       if ((this->zone_map_rows[param_2][param_1 + -1] == 0xff) &&
    //          ((uint)(0.0 < this->terrain_passability_rules
    //                        [(byte)this->map->map_row_offset[param_2][param_1 + -1].field_0x5 & 0x1f]) ==
    //           (_param_3 & 0xff))) {
    //         this->zone_map_rows[param_2][param_1 + -1] = uVar1;
    //         zone_push(&local_c,&zone_queue,param_1 + -1,param_2);
    //       }
    //     }
    //     if (0 < param_2) {
    //       if ((this->zone_map_rows[param_2 + -1][param_1] == 0xff) &&
    //          ((uint)(0.0 < this->terrain_passability_rules
    //                        [(byte)this->map->map_row_offset[param_2 + -1][param_1].field_0x5 & 0x1f]) ==
    //           (_param_3 & 0xff))) {
    //         this->zone_map_rows[param_2 + -1][param_1] = uVar1;
    //         zone_push(&local_c,&zone_queue,param_1,param_2 + -1);
    //       }
    //     }
    //     if (param_1 < local_8) {
    //       if ((this->zone_map_rows[param_2][param_1 + 1] == 0xff) &&
    //          ((uint)(0.0 < this->terrain_passability_rules
    //                        [(byte)this->map->map_row_offset[param_2][param_1 + 1].field_0x5 & 0x1f]) ==
    //           (_param_3 & 0xff))) {
    //         this->zone_map_rows[param_2][param_1 + 1] = uVar1;
    //         zone_push(&local_c,&zone_queue,param_1 + 1,param_2);
    //       }
    //     }
    //     if (param_2 < local_4) {
    //       if ((this->zone_map_rows[param_2 + 1][param_1] == 0xff) &&
    //          ((uint)(0.0 < this->terrain_passability_rules
    //                        [(byte)this->map->map_row_offset[param_2 + 1][param_1].field_0x5 & 0x1f]) ==
    //           (_param_3 & 0xff))) {
    //         this->zone_map_rows[param_2 + 1][param_1] = uVar1;
    //         zone_push(&local_c,&zone_queue,param_1,param_2 + 1);
    //       }
    //     }
    //     uVar2 = zone_pop(&local_c,&zone_queue,&param_1,&param_2);
    //   } while (uVar2 != '\0');
    //   return;
    // }
    // 
    // 
}

// Offset: 0x00546E50
RGE_Zone_Map* check_info(RGE_Zone_Map* this_, float* param_2, long param_3) {
    // --- Ghidra decompiler output ---
    // 
    // /* public: class RGE_Zone_Map * __thiscall RGE_Zone_Map::check_info(float *,long) */
    // 
    // RGE_Zone_Map * __thiscall RGE_Zone_Map::check_info(RGE_Zone_Map *this,float *param_1,long param_2)
    // 
    // {
    //   int iVar1;
    //   int iVar2;
    //   
    //   iVar1 = this->terrain_passability_rules_num;
    //   if (param_2 != iVar1) {
    //     return (RGE_Zone_Map *)0x0;
    //   }
    //   iVar2 = 0;
    //   if (0 < iVar1) {
    //     do {
    //       if (0.0 < param_1[iVar2]) {
    //         if (this->terrain_passability_rules[iVar2] <= 0.0) {
    //           return (RGE_Zone_Map *)0x0;
    //         }
    //       }
    //       else if (0.0 < this->terrain_passability_rules[iVar2]) {
    //         return (RGE_Zone_Map *)0x0;
    //       }
    //       iVar2 = iVar2 + 1;
    //     } while (iVar2 < iVar1);
    //   }
    //   return this;
    // }
    // 
    // 
}

// Offset: 0x00546EB0
uchar get_zone_info(RGE_Zone_Map* this_, long param_2, long param_3) {
    // --- Ghidra decompiler output ---
    // 
    // /* public: unsigned char __thiscall RGE_Zone_Map::get_zone_info(long,long) */
    // 
    // uchar __thiscall RGE_Zone_Map::get_zone_info(RGE_Zone_Map *this,long param_1,long param_2)
    // 
    // {
    //   return this->zone_map_rows[param_2][param_1];
    // }
    // 
    // 
}

// Offset: 0x00546ED0
int withinRange(RGE_Zone_Map* this_, XYPoint param_2, XYPoint param_3, float param_4) {
    // --- Ghidra decompiler output ---
    // 
    // /* public: int __thiscall RGE_Zone_Map::withinRange(struct XYPoint,struct XYPoint,float) */
    // 
    // int __thiscall
    // RGE_Zone_Map::withinRange(RGE_Zone_Map *this,XYPoint param_1,XYPoint param_2,float param_3)
    // 
    // {
    //   int iVar1;
    //   
    //   iVar1 = withinRange(this,this->zone_map_rows[param_1.y][param_1.x],param_2,param_3);
    //   return iVar1;
    // }
    // 
    // 
}

// Offset: 0x00546F00
int withinRange(RGE_Zone_Map* this_, uchar param_2, XYPoint param_3, float param_4) {
    // --- Ghidra decompiler output ---
    // 
    // /* public: int __thiscall RGE_Zone_Map::withinRange(unsigned char,struct XYPoint,float) */
    // 
    // int __thiscall
    // RGE_Zone_Map::withinRange(RGE_Zone_Map *this,uchar param_1,XYPoint param_2,float param_3)
    // 
    // {
    //   int iVar1;
    //   int iVar2;
    //   int iVar3;
    //   int iVar4;
    //   int iVar5;
    //   int iVar6;
    //   XYPoint max;
    //   
    //   iVar1 = __ftol();
    //   iVar3 = param_2.x - iVar1;
    //   iVar6 = param_2.y - iVar1;
    //   if (iVar3 < 0) {
    //     iVar3 = 0;
    //   }
    //   if (iVar6 < 0) {
    //     iVar6 = 0;
    //   }
    //   iVar5 = this->map->map_width + -1;
    //   max.y = param_2.x + iVar1;
    //   if (iVar5 < param_2.x + iVar1) {
    //     max.y = iVar5;
    //   }
    //   iVar2 = this->map->map_height + -1;
    //   iVar5 = param_2.y + iVar1;
    //   if (iVar2 < param_2.y + iVar1) {
    //     iVar5 = iVar2;
    //   }
    //   if (max.y < iVar3) {
    //     return 0;
    //   }
    //   iVar1 = param_2.x - iVar3;
    //   do {
    //     if (iVar6 <= iVar5) {
    //       iVar4 = param_2.y - iVar6;
    //       iVar2 = iVar6;
    //       do {
    //         if ((SQRT((float)(iVar4 * iVar4 + iVar1 * iVar1)) <= param_3) &&
    //            (this->zone_map_rows[iVar2][iVar3] == param_1)) {
    //           return 1;
    //         }
    //         iVar2 = iVar2 + 1;
    //         iVar4 = iVar4 + -1;
    //       } while (iVar2 <= iVar5);
    //     }
    //     iVar3 = iVar3 + 1;
    //     iVar1 = iVar1 + -1;
    //     if (max.y < iVar3) {
    //       return 0;
    //     }
    //   } while( true );
    // }
    // 
    // 
}

// Offset: 0x00547000
int numberTilesInZone(RGE_Zone_Map* this_, uchar param_2) {
    // --- Ghidra decompiler output ---
    // 
    // /* WARNING: Variable defined which should be unmapped: mapWidth */
    // /* public: int __thiscall RGE_Zone_Map::numberTilesInZone(unsigned char) */
    // 
    // int __thiscall RGE_Zone_Map::numberTilesInZone(RGE_Zone_Map *this,uchar param_1)
    // 
    // {
    //   int iVar1;
    //   int iVar2;
    //   uint uVar3;
    //   uchar uVar4;
    //   uchar **ppuVar5;
    //   int iVar6;
    //   int iVar7;
    //   int mapWidth;
    //   
    //   uVar4 = param_1;
    //   uVar3 = (uint)param_1;
    //   iVar6 = this->numberTilesInZoneValue[uVar3];
    //   if (iVar6 < 1) {
    //     iVar7 = 0;
    //     iVar1 = this->map->map_width;
    //     iVar2 = this->map->map_height;
    //     _param_1 = 0;
    //     iVar6 = 0;
    //     if (0 < iVar1) {
    //       do {
    //         if (0 < iVar2) {
    //           ppuVar5 = this->zone_map_rows;
    //           iVar6 = iVar2;
    //           do {
    //             if ((*ppuVar5)[iVar7] == uVar4) {
    //               _param_1 = _param_1 + 1;
    //             }
    //             ppuVar5 = ppuVar5 + 1;
    //             iVar6 = iVar6 + -1;
    //           } while (iVar6 != 0);
    //         }
    //         iVar7 = iVar7 + 1;
    //         iVar6 = _param_1;
    //       } while (iVar7 < iVar1);
    //     }
    //     this->numberTilesInZoneValue[uVar3] = iVar6;
    //   }
    //   return iVar6;
    // }
    // 
    // 
}

// Offset: 0x00547080
int findClosestPointInTerrainType(RGE_Zone_Map* this_, XYPoint param_2, XYPoint* param_3, int param_4, int param_5, int param_6) {
    // --- Ghidra decompiler output ---
    // 
    // /* public: int __thiscall RGE_Zone_Map::findClosestPointInTerrainType(struct XYPoint,struct XYPoint
    //    &,int,int,int) */
    // 
    // int __thiscall
    // RGE_Zone_Map::findClosestPointInTerrainType
    //           (RGE_Zone_Map *this,XYPoint param_1,XYPoint *param_2,int param_3,int param_4,int param_5)
    // 
    // {
    //   byte bVar1;
    //   int iVar2;
    //   int iVar3;
    //   int iVar4;
    //   int iVar5;
    //   int iVar6;
    //   int iVar7;
    //   XYPoint max;
    //   XYPoint min;
    //   int local_4;
    //   
    //   iVar5 = param_1.x - param_5;
    //   local_4 = param_1.y - param_5;
    //   if (iVar5 < 0) {
    //     iVar5 = 0;
    //   }
    //   if (local_4 < 0) {
    //     local_4 = 0;
    //   }
    //   iVar4 = this->map->map_width + -1;
    //   iVar3 = param_5 + param_1.x;
    //   if (iVar4 < param_5 + param_1.x) {
    //     iVar3 = iVar4;
    //   }
    //   iVar4 = this->map->map_height + -1;
    //   min.x = param_1.y + param_5;
    //   if (iVar4 < param_1.y + param_5) {
    //     min.x = iVar4;
    //   }
    //   iVar4 = -1;
    //   if (iVar5 <= iVar3) {
    //     param_5 = param_1.x - iVar5;
    //     do {
    //       if (local_4 <= min.x) {
    //         iVar7 = param_1.y - local_4;
    //         iVar6 = local_4;
    //         do {
    //           bVar1 = RGE_Map::get_terrain(this->map,(short)iVar5,(short)iVar6);
    //           if ((((uint)bVar1 == param_3) || ((uint)bVar1 == param_4)) &&
    //              ((iVar2 = param_5 * param_5 + iVar7 * iVar7, iVar4 == -1 || (iVar2 < iVar4)))) {
    //             param_2->x = iVar5;
    //             param_2->y = iVar6;
    //             iVar4 = iVar2;
    //           }
    //           iVar6 = iVar6 + 1;
    //           iVar7 = iVar7 + -1;
    //         } while (iVar6 <= min.x);
    //       }
    //       iVar5 = iVar5 + 1;
    //       param_5 = param_5 + -1;
    //     } while (iVar5 <= iVar3);
    //   }
    //   return (uint)(iVar4 != -1);
    // }
    // 
    // 
}

// Offset: 0x00547180
undefined RGE_Zone_Map_List(RGE_Zone_Map_List* this_, int param_2, RGE_Map* param_3) {
    // --- Ghidra decompiler output ---
    // 
    // /* public: __thiscall RGE_Zone_Map_List::RGE_Zone_Map_List(int,class RGE_Map *) */
    // 
    // RGE_Zone_Map_List * __thiscall
    // RGE_Zone_Map_List::RGE_Zone_Map_List(RGE_Zone_Map_List *this,int param_1,RGE_Map *param_2)
    // 
    // {
    //   long *plVar1;
    //   RGE_Zone_Map **ppRVar2;
    //   RGE_Zone_Map *pRVar3;
    //   int iVar4;
    //   int iVar5;
    //   undefined4 *unaff_FS_OFFSET;
    //   undefined4 local_c;
    //   code *pcStack_8;
    //   undefined4 local_4;
    //   
    //   local_c = *unaff_FS_OFFSET;
    //   local_4 = 0xffffffff;
    //   pcStack_8 = FUN_00561e8b;
    //   *unaff_FS_OFFSET = &local_c;
    //   plVar1 = &this->zone_map_num;
    //   this->zone_maps = (RGE_Zone_Map **)0x0;
    //   this->map = param_2;
    //   rge_read(param_1,plVar1,4);
    //   if (*plVar1 < 1) {
    //     this->zone_maps = (RGE_Zone_Map **)0x0;
    //   }
    //   else {
    //     ppRVar2 = (RGE_Zone_Map **)calloc(*plVar1,4);
    //     this->zone_maps = ppRVar2;
    //     iVar4 = 0;
    //     if (0 < *plVar1) {
    //       do {
    //         pRVar3 = (RGE_Zone_Map *)operator_new(0x51c);
    //         local_4 = 0;
    //         if (pRVar3 == (RGE_Zone_Map *)0x0) {
    //           pRVar3 = (RGE_Zone_Map *)0x0;
    //         }
    //         else {
    //           pRVar3 = (RGE_Zone_Map *)RGE_Zone_Map::RGE_Zone_Map(pRVar3,param_1,this->map);
    //         }
    //         iVar5 = iVar4 + 1;
    //         local_4 = 0xffffffff;
    //         this->zone_maps[iVar4] = pRVar3;
    //         iVar4 = iVar5;
    //       } while (iVar5 < *plVar1);
    //     }
    //   }
    //   *unaff_FS_OFFSET = local_c;
    //   return this;
    // }
    // 
    // 
}

// Offset: 0x00547240
undefined RGE_Zone_Map_List(RGE_Zone_Map_List* this_, RGE_Map* param_2) {
    // --- Ghidra decompiler output ---
    // 
    // /* public: __thiscall RGE_Zone_Map_List::RGE_Zone_Map_List(class RGE_Map *) */
    // 
    // void __thiscall RGE_Zone_Map_List::RGE_Zone_Map_List(RGE_Zone_Map_List *this,RGE_Map *param_1)
    // 
    // {
    //   this->map = param_1;
    //   this->zone_maps = (RGE_Zone_Map **)0x0;
    //   this->zone_map_num = 0;
    //   return;
    // }
    // 
    // 
}

// Offset: 0x00547260
void RGE_Zone_Map_List(RGE_Zone_Map_List* this_) {
    // --- Ghidra decompiler output ---
    // 
    // /* public: __thiscall RGE_Zone_Map_List::~RGE_Zone_Map_List(void) */
    // 
    // void __thiscall RGE_Zone_Map_List::~RGE_Zone_Map_List(RGE_Zone_Map_List *this)
    // 
    // {
    //   RGE_Zone_Map *this_00;
    //   int iVar1;
    //   
    //   if ((this->zone_maps != (RGE_Zone_Map **)0x0) && (0 < this->zone_map_num)) {
    //     iVar1 = 0;
    //     if (0 < this->zone_map_num) {
    //       do {
    //         this_00 = this->zone_maps[iVar1];
    //         if (this_00 != (RGE_Zone_Map *)0x0) {
    //           RGE_Zone_Map::~RGE_Zone_Map(this_00);
    //           operator_delete(this_00);
    //         }
    //         iVar1 = iVar1 + 1;
    //       } while (iVar1 < this->zone_map_num);
    //     }
    //     free(this->zone_maps);
    //     this->zone_maps = (RGE_Zone_Map **)0x0;
    //     this->zone_map_num = 0;
    //   }
    //   return;
    // }
    // 
    // 
}

// Offset: 0x00547270
void save(RGE_Zone_Map_List* this_, int param_2) {
    // --- Ghidra decompiler output ---
    // 
    // /* public: void __thiscall RGE_Zone_Map_List::save(int) */
    // 
    // void __thiscall RGE_Zone_Map_List::save(RGE_Zone_Map_List *this,int param_1)
    // 
    // {
    //   long *plVar1;
    //   int iVar2;
    //   
    //   plVar1 = &this->zone_map_num;
    //   rge_write(param_1,plVar1,4);
    //   if ((0 < *plVar1) && (iVar2 = 0, 0 < *plVar1)) {
    //     do {
    //       RGE_Zone_Map::save(this->zone_maps[iVar2],param_1);
    //       iVar2 = iVar2 + 1;
    //     } while (iVar2 < *plVar1);
    //   }
    //   return;
    // }
    // 
    // 
}

// Offset: 0x005472B0
long create_zone_map(RGE_Zone_Map_List* this_, float* param_2, long param_3) {
    // --- Ghidra decompiler output ---
    // 
    // /* public: long __thiscall RGE_Zone_Map_List::create_zone_map(float *,long) */
    // 
    // long __thiscall
    // RGE_Zone_Map_List::create_zone_map(RGE_Zone_Map_List *this,float *param_1,long param_2)
    // 
    // {
    //   uchar uVar1;
    //   RGE_Zone_Map *pRVar2;
    //   RGE_Zone_Map **ppRVar3;
    //   uint uVar4;
    //   int iVar5;
    //   RGE_Zone_Map **ppRVar6;
    //   RGE_Zone_Map **ppRVar7;
    //   undefined4 *unaff_FS_OFFSET;
    //   undefined4 local_c;
    //   code *pcStack_8;
    //   undefined4 local_4;
    //   
    //   local_c = *unaff_FS_OFFSET;
    //   local_4 = 0xffffffff;
    //   pcStack_8 = FUN_00561eab;
    //   *unaff_FS_OFFSET = &local_c;
    //   iVar5 = 0;
    //   if (0 < this->zone_map_num) {
    //     do {
    //       pRVar2 = RGE_Zone_Map::check_info(this->zone_maps[iVar5],param_1,param_2);
    //       if (pRVar2 != (RGE_Zone_Map *)0x0) {
    //         uVar1 = RGE_Zone_Map::do_zone_map(this->zone_maps[iVar5]);
    //         if (uVar1 == '\0') {
    //           iVar5 = -1;
    //         }
    //         goto LAB_0054737c;
    //       }
    //       iVar5 = iVar5 + 1;
    //     } while (iVar5 < this->zone_map_num);
    //   }
    //   ppRVar3 = (RGE_Zone_Map **)calloc(this->zone_map_num + 1,4);
    //   if (this->zone_maps != (RGE_Zone_Map **)0x0) {
    //     ppRVar6 = this->zone_maps;
    //     ppRVar7 = ppRVar3;
    //     for (uVar4 = this->zone_map_num & 0x3fffffff; uVar4 != 0; uVar4 = uVar4 - 1) {
    //       *ppRVar7 = *ppRVar6;
    //       ppRVar6 = ppRVar6 + 1;
    //       ppRVar7 = ppRVar7 + 1;
    //     }
    //     for (iVar5 = 0; iVar5 != 0; iVar5 = iVar5 + -1) {
    //       *(undefined1 *)ppRVar7 = *(undefined1 *)ppRVar6;
    //       ppRVar6 = (RGE_Zone_Map **)((int)ppRVar6 + 1);
    //       ppRVar7 = (RGE_Zone_Map **)((int)ppRVar7 + 1);
    //     }
    //     free(this->zone_maps);
    //   }
    //   pRVar2 = (RGE_Zone_Map *)operator_new(0x51c);
    //   local_4 = 0;
    //   if (pRVar2 == (RGE_Zone_Map *)0x0) {
    //     pRVar2 = (RGE_Zone_Map *)0x0;
    //   }
    //   else {
    //     pRVar2 = (RGE_Zone_Map *)RGE_Zone_Map::RGE_Zone_Map(pRVar2,this->map,param_1,param_2);
    //   }
    //   ppRVar3[this->zone_map_num] = pRVar2;
    //   iVar5 = this->zone_map_num;
    //   this->zone_maps = ppRVar3;
    //   this->zone_map_num = iVar5 + 1;
    // LAB_0054737c:
    //   *unaff_FS_OFFSET = local_c;
    //   return iVar5;
    // }
    // 
    // 
}

// Offset: 0x005473B0
RGE_Zone_Map* get_zone_map(RGE_Zone_Map_List* this_, float* param_2, long param_3, int* param_4) {
    // --- Ghidra decompiler output ---
    // 
    // /* public: class RGE_Zone_Map * __thiscall RGE_Zone_Map_List::get_zone_map(float *,long,int &) */
    // 
    // RGE_Zone_Map * __thiscall
    // RGE_Zone_Map_List::get_zone_map(RGE_Zone_Map_List *this,float *param_1,long param_2,int *param_3)
    // 
    // {
    //   RGE_Zone_Map *pRVar1;
    //   RGE_Zone_Map **ppRVar2;
    //   uint uVar3;
    //   int iVar4;
    //   RGE_Zone_Map **ppRVar5;
    //   RGE_Zone_Map **ppRVar6;
    //   undefined4 *unaff_FS_OFFSET;
    //   undefined4 local_c;
    //   code *pcStack_8;
    //   undefined4 local_4;
    //   
    //   local_4 = 0xffffffff;
    //   pcStack_8 = FUN_00561ecb;
    //   local_c = *unaff_FS_OFFSET;
    //   *unaff_FS_OFFSET = &local_c;
    //   iVar4 = 0;
    //   if (0 < this->zone_map_num) {
    //     do {
    //       pRVar1 = RGE_Zone_Map::check_info(this->zone_maps[iVar4],param_1,param_2);
    //       if (pRVar1 != (RGE_Zone_Map *)0x0) {
    //         *param_3 = iVar4;
    //         pRVar1 = this->zone_maps[iVar4];
    //         goto LAB_00547485;
    //       }
    //       iVar4 = iVar4 + 1;
    //     } while (iVar4 < this->zone_map_num);
    //   }
    //   ppRVar2 = (RGE_Zone_Map **)calloc(this->zone_map_num + 1,4);
    //   if (this->zone_maps != (RGE_Zone_Map **)0x0) {
    //     ppRVar5 = this->zone_maps;
    //     ppRVar6 = ppRVar2;
    //     for (uVar3 = this->zone_map_num & 0x3fffffff; uVar3 != 0; uVar3 = uVar3 - 1) {
    //       *ppRVar6 = *ppRVar5;
    //       ppRVar5 = ppRVar5 + 1;
    //       ppRVar6 = ppRVar6 + 1;
    //     }
    //     for (iVar4 = 0; iVar4 != 0; iVar4 = iVar4 + -1) {
    //       *(undefined1 *)ppRVar6 = *(undefined1 *)ppRVar5;
    //       ppRVar5 = (RGE_Zone_Map **)((int)ppRVar5 + 1);
    //       ppRVar6 = (RGE_Zone_Map **)((int)ppRVar6 + 1);
    //     }
    //     free(this->zone_maps);
    //   }
    //   pRVar1 = (RGE_Zone_Map *)operator_new(0x51c);
    //   local_4 = 0;
    //   if (pRVar1 == (RGE_Zone_Map *)0x0) {
    //     pRVar1 = (RGE_Zone_Map *)0x0;
    //   }
    //   else {
    //     pRVar1 = (RGE_Zone_Map *)RGE_Zone_Map::RGE_Zone_Map(pRVar1,this->map,param_1,param_2);
    //   }
    //   ppRVar2[this->zone_map_num] = pRVar1;
    //   iVar4 = this->zone_map_num;
    //   this->zone_maps = ppRVar2;
    //   this->zone_map_num = iVar4 + 1;
    //   *param_3 = iVar4;
    //   pRVar1 = ppRVar2[this->zone_map_num + -1];
    // LAB_00547485:
    //   *unaff_FS_OFFSET = local_c;
    //   return pRVar1;
    // }
    // 
    // 
}

// Offset: 0x005474B0
RGE_Zone_Map* get_zone_map(RGE_Zone_Map_List* this_, long param_2) {
    // --- Ghidra decompiler output ---
    // 
    // /* public: class RGE_Zone_Map * __thiscall RGE_Zone_Map_List::get_zone_map(long) */
    // 
    // RGE_Zone_Map * __thiscall RGE_Zone_Map_List::get_zone_map(RGE_Zone_Map_List *this,long param_1)
    // 
    // {
    //   if ((param_1 < this->zone_map_num) && (-1 < param_1)) {
    //     return this->zone_maps[param_1];
    //   }
    //   return (RGE_Zone_Map *)0x0;
    // }
    // 
    // 
}

// Offset: 0x005474D0
void delete_zone_maps(RGE_Zone_Map_List* this_) {
    // --- Ghidra decompiler output ---
    // 
    // /* public: void __thiscall RGE_Zone_Map_List::delete_zone_maps(void) */
    // 
    // void __thiscall RGE_Zone_Map_List::delete_zone_maps(RGE_Zone_Map_List *this)
    // 
    // {
    //   RGE_Zone_Map *this_00;
    //   int iVar1;
    //   
    //   if ((this->zone_maps != (RGE_Zone_Map **)0x0) && (0 < this->zone_map_num)) {
    //     iVar1 = 0;
    //     if (0 < this->zone_map_num) {
    //       do {
    //         this_00 = this->zone_maps[iVar1];
    //         if (this_00 != (RGE_Zone_Map *)0x0) {
    //           RGE_Zone_Map::~RGE_Zone_Map(this_00);
    //           operator_delete(this_00);
    //         }
    //         iVar1 = iVar1 + 1;
    //       } while (iVar1 < this->zone_map_num);
    //     }
    //     free(this->zone_maps);
    //     this->zone_maps = (RGE_Zone_Map **)0x0;
    //     this->zone_map_num = 0;
    //   }
    //   return;
    // }
    // 
    // 
}

