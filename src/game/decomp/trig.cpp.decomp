// Auto-generated decompiler unit: trig.cpp.decomp
// SourceMap: C:/msdev/work/age1_x1/trig.cpp
#include "../include/common.h"

// Offset: 0x0052A730
undefined TRIGONOMETRY(TRIGONOMETRY* this_) {
    // --- Ghidra decompiler output ---
    // 
    // /* WARNING: Variable defined which should be unmapped: i */
    // /* public: __thiscall TRIGONOMETRY::TRIGONOMETRY(void) */
    // 
    // void __thiscall TRIGONOMETRY::TRIGONOMETRY(TRIGONOMETRY *this)
    // 
    // {
    //   float *pfVar1;
    //   float10 fVar2;
    //   float10 fVar3;
    //   float10 fVar4;
    //   int i;
    //   int local_4;
    //   
    //   local_4 = 0;
    //   pfVar1 = this->tane;
    //   do {
    //     fVar2 = (float10)local_4 * (float10)0.001533980788;
    //     fVar3 = (float10)fsin(fVar2);
    //     fVar4 = (float10)fcos(fVar2);
    //     ((TRIGONOMETRY *)(pfVar1 + -0x2000))->sines[0] = (float)fVar3;
    //     pfVar1[-0x1000] = (float)fVar4;
    //     if ((local_4 == 0x400) || (local_4 == 0xc00)) {
    //       *pfVar1 = 0.0;
    //     }
    //     else {
    //       fVar3 = (float10)fptan(fVar2);
    //       *pfVar1 = (float)fVar3;
    //     }
    //     if ((local_4 == 0) || (local_4 == 0x800)) {
    //       pfVar1[0x1000] = 0.0;
    //     }
    //     else {
    //       fVar2 = (float10)fpatan(fVar2,(float10)1);
    //       pfVar1[0x1000] = (float)fVar2;
    //     }
    //     local_4 = local_4 + 1;
    //     pfVar1 = pfVar1 + 1;
    //   } while (local_4 < 0x1000);
    //   pfVar1 = this->tane360;
    //   local_4 = 0;
    //   do {
    //     fVar2 = (float10)local_4 * (float10)0.01745329252;
    //     fVar3 = (float10)fsin(fVar2);
    //     fVar4 = (float10)fcos(fVar2);
    //     pfVar1[-0x2d0] = (float)fVar3;
    //     pfVar1[-0x168] = (float)fVar4;
    //     if ((local_4 == 0x5a) || (local_4 == 0x10e)) {
    //       *pfVar1 = 0.0;
    //     }
    //     else {
    //       fVar3 = (float10)fptan(fVar2);
    //       *pfVar1 = (float)fVar3;
    //     }
    //     if ((local_4 == 0) || (local_4 == 0xb4)) {
    //       pfVar1[0x168] = 0.0;
    //     }
    //     else {
    //       fVar2 = (float10)fpatan(fVar2,(float10)1);
    //       pfVar1[0x168] = (float)fVar2;
    //     }
    //     local_4 = local_4 + 1;
    //     pfVar1 = pfVar1 + 1;
    //   } while (local_4 < 0x168);
    //   return;
    // }
    // 
    // 
}

// Offset: 0x0052A830
int RestrictAngle(TRIGONOMETRY* this_, int param_2) {
    // --- Ghidra decompiler output ---
    // 
    // /* private: int __thiscall TRIGONOMETRY::RestrictAngle(int) */
    // 
    // int __thiscall TRIGONOMETRY::RestrictAngle(TRIGONOMETRY *this,int param_1)
    // 
    // {
    //   int iVar1;
    //   uint uVar2;
    //   
    //   uVar2 = param_1 >> 0x1f;
    //   iVar1 = ((param_1 ^ uVar2) - uVar2 & 0xfff ^ uVar2) - uVar2;
    //   if (iVar1 < 0) {
    //     iVar1 = -iVar1;
    //   }
    //   return iVar1;
    // }
    // 
    // 
}

// Offset: 0x0052A850
int RestrictAngle360(TRIGONOMETRY* this_, int param_2) {
    // --- Ghidra decompiler output ---
    // 
    // /* private: int __thiscall TRIGONOMETRY::RestrictAngle360(int) */
    // 
    // int __thiscall TRIGONOMETRY::RestrictAngle360(TRIGONOMETRY *this,int param_1)
    // 
    // {
    //   int iVar1;
    //   
    //   iVar1 = param_1 % 0x168;
    //   if (iVar1 < 0) {
    //     iVar1 = -iVar1;
    //   }
    //   return iVar1;
    // }
    // 
    // 
}

// Offset: 0x0052A870
float sine(TRIGONOMETRY* this_, int param_2) {
    // --- Ghidra decompiler output ---
    // 
    // /* public: float __thiscall TRIGONOMETRY::sine(int) */
    // 
    // float __thiscall TRIGONOMETRY::sine(TRIGONOMETRY *this,int param_1)
    // 
    // {
    //   int iVar1;
    //   
    //   iVar1 = RestrictAngle(this,param_1);
    //   return this->sines[iVar1];
    // }
    // 
    // 
}

// Offset: 0x0052A890
float cosine(TRIGONOMETRY* this_, int param_2) {
    // --- Ghidra decompiler output ---
    // 
    // /* public: float __thiscall TRIGONOMETRY::cosine(int) */
    // 
    // float __thiscall TRIGONOMETRY::cosine(TRIGONOMETRY *this,int param_1)
    // 
    // {
    //   int iVar1;
    //   
    //   iVar1 = RestrictAngle(this,param_1);
    //   return this->cose[iVar1];
    // }
    // 
    // 
}

// Offset: 0x0052A8B0
float tangent(TRIGONOMETRY* this_, int param_2) {
    // --- Ghidra decompiler output ---
    // 
    // /* public: float __thiscall TRIGONOMETRY::tangent(int) */
    // 
    // float __thiscall TRIGONOMETRY::tangent(TRIGONOMETRY *this,int param_1)
    // 
    // {
    //   int iVar1;
    //   
    //   iVar1 = RestrictAngle(this,param_1);
    //   return this->tane[iVar1];
    // }
    // 
    // 
}

// Offset: 0x0052A8D0
float atangent(TRIGONOMETRY* this_, int param_2) {
    // --- Ghidra decompiler output ---
    // 
    // /* public: float __thiscall TRIGONOMETRY::atangent(int) */
    // 
    // float __thiscall TRIGONOMETRY::atangent(TRIGONOMETRY *this,int param_1)
    // 
    // {
    //   int iVar1;
    //   
    //   iVar1 = RestrictAngle(this,param_1);
    //   return this->atane[iVar1];
    // }
    // 
    // 
}

// Offset: 0x0052A8F0
float sin360(TRIGONOMETRY* this_, int param_2) {
    // --- Ghidra decompiler output ---
    // 
    // /* public: float __thiscall TRIGONOMETRY::sin360(int) */
    // 
    // float __thiscall TRIGONOMETRY::sin360(TRIGONOMETRY *this,int param_1)
    // 
    // {
    //   int iVar1;
    //   
    //   iVar1 = RestrictAngle360(this,param_1);
    //   return this->sine360[iVar1];
    // }
    // 
    // 
}

// Offset: 0x0052A910
float cos360(TRIGONOMETRY* this_, int param_2) {
    // --- Ghidra decompiler output ---
    // 
    // /* public: float __thiscall TRIGONOMETRY::cos360(int) */
    // 
    // float __thiscall TRIGONOMETRY::cos360(TRIGONOMETRY *this,int param_1)
    // 
    // {
    //   int iVar1;
    //   
    //   iVar1 = RestrictAngle360(this,param_1);
    //   return this->cose360[iVar1];
    // }
    // 
    // 
}

// Offset: 0x0052A930
float tan360(TRIGONOMETRY* this_, int param_2) {
    // --- Ghidra decompiler output ---
    // 
    // /* public: float __thiscall TRIGONOMETRY::tan360(int) */
    // 
    // float __thiscall TRIGONOMETRY::tan360(TRIGONOMETRY *this,int param_1)
    // 
    // {
    //   int iVar1;
    //   
    //   iVar1 = RestrictAngle360(this,param_1);
    //   return this->tane360[iVar1];
    // }
    // 
    // 
}

// Offset: 0x0052A950
float atan360(TRIGONOMETRY* this_, int param_2) {
    // --- Ghidra decompiler output ---
    // 
    // /* public: float __thiscall TRIGONOMETRY::atan360(int) */
    // 
    // float __thiscall TRIGONOMETRY::atan360(TRIGONOMETRY *this,int param_1)
    // 
    // {
    //   int iVar1;
    //   
    //   iVar1 = RestrictAngle360(this,param_1);
    //   return this->atane360[iVar1];
    // }
    // 
    // 
}

// Offset: 0x0052A980
undefined E1() {
    // --- Ghidra decompiler output ---
    // 
    // void _E1(void)
    // 
    // {
    //   TRIGONOMETRY::TRIGONOMETRY(&trig);
    //   return;
    // }
    // 
    // 
}

