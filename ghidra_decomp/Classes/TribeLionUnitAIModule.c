// Class: TribeLionUnitAIModule
// Size:  0x134
//
// VTable Layout:
// [00] `vector_deleting_destructor'
// [01] save
// [02] load
// [03] owner
// [04] order
// [05] notify
// [06] notifyCommander
// [07] notifyCommander
// [08] search
// [09] importantWhenDead
// [10] retryableOrder
// [11] actionRequiresLiveTarget
// [12] bestUnitToAttack
// [13] mostDangerousEnemy
// [14] weakestEnemy
// [15] closestAttacker
// [16] closestObject
// [17] closestResourceObject
// [18] closestUndiscoveredTile
// [19] logDebug
// [20] canAttackUnit
// [21] canAttackUnitAtNeutrality
// [22] stopObject
// [23] attackObject
// [24] attackRoundupObject
// [25] huntObject
// [26] gatherObject
// [27] convertObject
// [28] healObject
// [29] repairObject
// [30] buildObject
// [31] tradeWithObject
// [32] explore
// [33] enterObject
// [34] unload
// [35] transportObject
// [36] moveTo
// [37] moveTo
// [38] moveTo
// [39] evasiveMoveTo
// [40] intelligentEvasiveMoveTo
// [41] runAwayFromAttackers
// [42] followObject
// [43] defendObject
// [44] defendPosition
// [45] seekAndDestroy
// [46] exploreAndDestroy
// [47] importantObject
// [48] convertToLOSResourceType
// [49] canConvert
// [50] processOrder
// [51] processNotify
// [52] processGroupNotify
// [53] processIdle
// [54] processMisc
// [55] processRetryableOrder
// [56] `vector_deleting_destructor'
// [57] save
// [58] load
// [59] owner
// [60] order
// [61] notify
// [62] notifyCommander
// [63] notifyCommander
// [64] search
// [65] importantWhenDead
// [66] retryableOrder
// [67] actionRequiresLiveTarget
// [68] bestUnitToAttack
// [69] mostDangerousEnemy
// [70] weakestEnemy
// [71] closestAttacker
// [72] closestObject
// [73] closestResourceObject
// [74] closestUndiscoveredTile
// [75] logDebug
// [76] canAttackUnit
// [77] canAttackUnitAtNeutrality
// [78] stopObject
// [79] attackObject
// [80] attackRoundupObject
// [81] huntObject
// [82] gatherObject
// [83] convertObject
// [84] healObject
// [85] repairObject
// [86] buildObject
// [87] tradeWithObject
// [88] explore
// [89] enterObject
// [90] unload
// [91] transportObject
// [92] moveTo
// [93] moveTo
// [94] moveTo
// [95] evasiveMoveTo
// [96] intelligentEvasiveMoveTo
// [97] runAwayFromAttackers
// [98] followObject
// [99] defendObject
// [100] defendPosition
// [101] seekAndDestroy
// [102] exploreAndDestroy
// [103] importantObject
// [104] convertToLOSResourceType
// [105] canConvert
// [106] processOrder
// [107] processNotify
// [108] processGroupNotify
// [109] processIdle
// [110] processMisc
// [111] processRetryableOrder
// [112] `vector_deleting_destructor'
// [113] save
// [114] load
// [115] owner
// [116] order
// [117] notify
// [118] notifyCommander
// [119] notifyCommander
// [120] search
// [121] importantWhenDead
// [122] retryableOrder
// [123] actionRequiresLiveTarget
// [124] bestUnitToAttack
// [125] mostDangerousEnemy
// [126] weakestEnemy
// [127] closestAttacker
// [128] closestObject
// [129] closestResourceObject
// [130] closestUndiscoveredTile
// [131] logDebug
// [132] canAttackUnit
// [133] canAttackUnitAtNeutrality
// [134] stopObject
// [135] attackObject
// [136] attackRoundupObject
// [137] huntObject
// [138] gatherObject
// [139] convertObject
// [140] healObject
// [141] repairObject
// [142] buildObject
// [143] tradeWithObject
// [144] explore
// [145] enterObject
// [146] unload
// [147] transportObject
// [148] moveTo
// [149] moveTo
// [150] moveTo
// [151] evasiveMoveTo
// [152] intelligentEvasiveMoveTo
// [153] runAwayFromAttackers
// [154] followObject
// [155] defendObject
// [156] defendPosition
// [157] seekAndDestroy
// [158] exploreAndDestroy
// [159] importantObject
// [160] convertToLOSResourceType
// [161] canConvert
// [162] processOrder
// [163] processNotify
// [164] processGroupNotify
// [165] processIdle
// [166] processMisc
// [167] processRetryableOrder
// [168] `scalar_deleting_destructor'
// [169] save
// [170] load
// [171] owner
// [172] order
// [173] notify
// [174] notifyCommander
// [175] notifyCommander
// [176] search
// [177] importantWhenDead
// [178] retryableOrder
// [179] actionRequiresLiveTarget
// [180] bestUnitToAttack
// [181] mostDangerousEnemy
// [182] weakestEnemy
// [183] closestAttacker
// [184] closestObject
// [185] closestResourceObject
// [186] closestUndiscoveredTile
// [187] logDebug
// [188] canAttackUnit
// [189] canAttackUnitAtNeutrality
// [190] stopObject
// [191] attackObject
// [192] attackRoundupObject
// [193] huntObject
// [194] gatherObject
// [195] convertObject
// [196] healObject
// [197] repairObject
// [198] buildObject
// [199] tradeWithObject
// [200] explore
// [201] enterObject
// [202] unload
// [203] transportObject
// [204] moveTo
// [205] moveTo
// [206] moveTo
// [207] evasiveMoveTo
// [208] intelligentEvasiveMoveTo
// [209] runAwayFromAttackers
// [210] followObject
// [211] defendObject
// [212] defendPosition
// [213] seekAndDestroy
// [214] exploreAndDestroy
// [215] importantObject
// [216] convertToLOSResourceType
// [217] canConvert
// [218] processOrder
// [219] processNotify
// [220] processGroupNotify
// [221] processIdle
// [222] processMisc
// [223] processRetryableOrder
// [224] `vector_deleting_destructor'
// [225] save
// [226] load
// [227] owner
// [228] order
// [229] notify
// [230] notifyCommander
// [231] notifyCommander
// [232] search
// [233] importantWhenDead
// [234] retryableOrder
// [235] actionRequiresLiveTarget
// [236] bestUnitToAttack
// [237] mostDangerousEnemy
// [238] weakestEnemy
// [239] closestAttacker
// [240] closestObject
// [241] closestResourceObject
// [242] closestUndiscoveredTile
// [243] logDebug
// [244] canAttackUnit
// [245] canAttackUnitAtNeutrality
// [246] stopObject
// [247] attackObject
// [248] attackRoundupObject
// [249] huntObject
// [250] gatherObject
// [251] convertObject
// [252] healObject
// [253] repairObject
// [254] buildObject
// [255] tradeWithObject
// [256] explore
// [257] enterObject
// [258] unload
// [259] transportObject
// [260] moveTo
// [261] moveTo
// [262] moveTo
// [263] evasiveMoveTo
// [264] intelligentEvasiveMoveTo
// [265] runAwayFromAttackers
// [266] followObject
// [267] defendObject
// [268] defendPosition
// [269] seekAndDestroy
// [270] exploreAndDestroy
// [271] importantObject
// [272] convertToLOSResourceType
// [273] canConvert
// [274] processOrder
// [275] processNotify
// [276] processGroupNotify
// [277] processIdle
// [278] processMisc
// [279] processRetryableOrder
// [280] bestUnitToHeal
// [281] bestUnitToConvert
// [282] `scalar_deleting_destructor'
// [283] save
// [284] load
// [285] owner
// [286] order
// [287] notify
// [288] notifyCommander
// [289] notifyCommander
// [290] search
// [291] importantWhenDead
// [292] retryableOrder
// [293] actionRequiresLiveTarget
// [294] bestUnitToAttack
// [295] mostDangerousEnemy
// [296] weakestEnemy
// [297] closestAttacker
// [298] closestObject
// [299] closestResourceObject
// [300] closestUndiscoveredTile
// [301] logDebug
// [302] canAttackUnit
// [303] canAttackUnitAtNeutrality
// [304] stopObject
// [305] attackObject
// [306] attackRoundupObject
// [307] huntObject
// [308] gatherObject
// [309] convertObject
// [310] healObject
// [311] repairObject
// [312] buildObject
// [313] tradeWithObject
// [314] explore
// [315] enterObject
// [316] unload
// [317] transportObject
// [318] moveTo
// [319] moveTo
// [320] moveTo
// [321] evasiveMoveTo
// [322] intelligentEvasiveMoveTo
// [323] runAwayFromAttackers
// [324] followObject
// [325] defendObject
// [326] defendPosition
// [327] seekAndDestroy
// [328] exploreAndDestroy
// [329] importantObject
// [330] convertToLOSResourceType
// [331] canConvert
// [332] processOrder
// [333] processNotify
// [334] processGroupNotify
// [335] processIdle
// [336] processMisc
// [337] processRetryableOrder
// [338] `scalar_deleting_destructor'
// [339] save
// [340] load
// [341] owner
// [342] order
// [343] notify
// [344] notifyCommander
// [345] notifyCommander
// [346] search
// [347] importantWhenDead
// [348] retryableOrder
// [349] actionRequiresLiveTarget
// [350] bestUnitToAttack
// [351] mostDangerousEnemy
// [352] weakestEnemy
// [353] closestAttacker
// [354] closestObject
// [355] closestResourceObject
// [356] closestUndiscoveredTile
// [357] logDebug
// [358] canAttackUnit
// [359] canAttackUnitAtNeutrality
// [360] stopObject
// [361] attackObject
// [362] attackRoundupObject
// [363] huntObject
// [364] gatherObject
// [365] convertObject
// [366] healObject
// [367] repairObject
// [368] buildObject
// [369] tradeWithObject
// [370] explore
// [371] enterObject
// [372] unload
// [373] transportObject
// [374] moveTo
// [375] moveTo
// [376] moveTo
// [377] evasiveMoveTo
// [378] intelligentEvasiveMoveTo
// [379] runAwayFromAttackers
// [380] followObject
// [381] defendObject
// [382] defendPosition
// [383] seekAndDestroy
// [384] exploreAndDestroy
// [385] importantObject
// [386] convertToLOSResourceType
// [387] canConvert
// [388] processOrder
// [389] processNotify
// [390] processGroupNotify
// [391] processIdle
// [392] processMisc
// [393] processRetryableOrder
// [394] `scalar_deleting_destructor'
// [395] save
// [396] load
// [397] owner
// [398] order
// [399] notify
// [400] notifyCommander
// [401] notifyCommander
// [402] search
// [403] importantWhenDead
// [404] retryableOrder
// [405] actionRequiresLiveTarget
// [406] bestUnitToAttack
// [407] mostDangerousEnemy
// [408] weakestEnemy
// [409] closestAttacker
// [410] closestObject
// [411] closestResourceObject
// [412] closestUndiscoveredTile
// [413] logDebug
// [414] canAttackUnit
// [415] canAttackUnitAtNeutrality
// [416] stopObject
// [417] attackObject
// [418] attackRoundupObject
// [419] huntObject
// [420] gatherObject
// [421] convertObject
// [422] healObject
// [423] repairObject
// [424] buildObject
// [425] tradeWithObject
// [426] explore
// [427] enterObject
// [428] unload
// [429] transportObject
// [430] moveTo
// [431] moveTo
// [432] moveTo
// [433] evasiveMoveTo
// [434] intelligentEvasiveMoveTo
// [435] runAwayFromAttackers
// [436] followObject
// [437] defendObject
// [438] defendPosition
// [439] seekAndDestroy
// [440] exploreAndDestroy
// [441] importantObject
// [442] convertToLOSResourceType
// [443] canConvert
// [444] processOrder
// [445] processNotify
// [446] processGroupNotify
// [447] processIdle
// [448] processMisc
// [449] processRetryableOrder
// [450] `scalar_deleting_destructor'
// [451] save
// [452] load
// [453] owner
// [454] order
// [455] notify
// [456] notifyCommander
// [457] notifyCommander
// [458] search
// [459] importantWhenDead
// [460] retryableOrder
// [461] actionRequiresLiveTarget
// [462] bestUnitToAttack
// [463] mostDangerousEnemy
// [464] weakestEnemy
// [465] closestAttacker
// [466] closestObject
// [467] closestResourceObject
// [468] closestUndiscoveredTile
// [469] logDebug
// [470] canAttackUnit
// [471] canAttackUnitAtNeutrality
// [472] stopObject
// [473] attackObject
// [474] attackRoundupObject
// [475] huntObject
// [476] gatherObject
// [477] convertObject
// [478] healObject
// [479] repairObject
// [480] buildObject
// [481] tradeWithObject
// [482] explore
// [483] enterObject
// [484] unload
// [485] transportObject
// [486] moveTo
// [487] moveTo
// [488] moveTo
// [489] evasiveMoveTo
// [490] intelligentEvasiveMoveTo
// [491] runAwayFromAttackers
// [492] followObject
// [493] defendObject
// [494] defendPosition
// [495] seekAndDestroy
// [496] exploreAndDestroy
// [497] importantObject
// [498] convertToLOSResourceType
// [499] canConvert
// [500] processOrder
// [501] processNotify
// [502] processGroupNotify
// [503] processIdle
// [504] processMisc
// [505] processRetryableOrder
// [506] `vector_deleting_destructor'
// [507] save
// [508] load
// [509] owner
// [510] order
// [511] notify
// [512] notifyCommander
// [513] notifyCommander
// [514] search
// [515] importantWhenDead
// [516] retryableOrder
// [517] actionRequiresLiveTarget
// [518] bestUnitToAttack
// [519] mostDangerousEnemy
// [520] weakestEnemy
// [521] closestAttacker
// [522] closestObject
// [523] closestResourceObject
// [524] closestUndiscoveredTile
// [525] logDebug
// [526] canAttackUnit
// [527] canAttackUnitAtNeutrality
// [528] stopObject
// [529] attackObject
// [530] attackRoundupObject
// [531] huntObject
// [532] gatherObject
// [533] convertObject
// [534] healObject
// [535] repairObject
// [536] buildObject
// [537] tradeWithObject
// [538] explore
// [539] enterObject
// [540] unload
// [541] transportObject
// [542] moveTo
// [543] moveTo
// [544] moveTo
// [545] evasiveMoveTo
// [546] intelligentEvasiveMoveTo
// [547] runAwayFromAttackers
// [548] followObject
// [549] defendObject
// [550] defendPosition
// [551] seekAndDestroy
// [552] exploreAndDestroy
// [553] importantObject
// [554] convertToLOSResourceType
// [555] canConvert
// [556] processOrder
// [557] processNotify
// [558] processGroupNotify
// [559] processIdle
// [560] processMisc
// [561] processRetryableOrder
// [562] `scalar_deleting_destructor'
// [563] save
// [564] load
// [565] owner
// [566] order
// [567] notify
// [568] notifyCommander
// [569] notifyCommander
// [570] search
// [571] importantWhenDead
// [572] retryableOrder
// [573] actionRequiresLiveTarget
// [574] bestUnitToAttack
// [575] mostDangerousEnemy
// [576] weakestEnemy
// [577] closestAttacker
// [578] closestObject
// [579] closestResourceObject
// [580] closestUndiscoveredTile
// [581] logDebug
// [582] canAttackUnit
// [583] canAttackUnitAtNeutrality
// [584] stopObject
// [585] attackObject
// [586] attackRoundupObject
// [587] huntObject
// [588] gatherObject
// [589] convertObject
// [590] healObject
// [591] repairObject
// [592] buildObject
// [593] tradeWithObject
// [594] explore
// [595] enterObject
// [596] unload
// [597] transportObject
// [598] moveTo
// [599] moveTo
// [600] moveTo
// [601] evasiveMoveTo
// [602] intelligentEvasiveMoveTo
// [603] runAwayFromAttackers
// [604] followObject
// [605] defendObject
// [606] defendPosition
// [607] seekAndDestroy
// [608] exploreAndDestroy
// [609] importantObject
// [610] convertToLOSResourceType
// [611] canConvert
// [612] processOrder
// [613] processNotify
// [614] processGroupNotify
// [615] processIdle
// [616] processMisc
// [617] processRetryableOrder
// [618] `scalar_deleting_destructor'
// [619] save
// [620] load
// [621] owner
// [622] order
// [623] notify
// [624] notifyCommander
// [625] notifyCommander
// [626] search
// [627] importantWhenDead
// [628] retryableOrder
// [629] actionRequiresLiveTarget
// [630] bestUnitToAttack
// [631] mostDangerousEnemy
// [632] weakestEnemy
// [633] closestAttacker
// [634] closestObject
// [635] closestResourceObject
// [636] closestUndiscoveredTile
// [637] logDebug
// [638] canAttackUnit
// [639] canAttackUnitAtNeutrality
// [640] stopObject
// [641] attackObject
// [642] attackRoundupObject
// [643] huntObject
// [644] gatherObject
// [645] convertObject
// [646] healObject
// [647] repairObject
// [648] buildObject
// [649] tradeWithObject
// [650] explore
// [651] enterObject
// [652] unload
// [653] transportObject
// [654] moveTo
// [655] moveTo
// [656] moveTo
// [657] evasiveMoveTo
// [658] intelligentEvasiveMoveTo
// [659] runAwayFromAttackers
// [660] followObject
// [661] defendObject
// [662] defendPosition
// [663] seekAndDestroy
// [664] exploreAndDestroy
// [665] importantObject
// [666] convertToLOSResourceType
// [667] canConvert
// [668] processOrder
// [669] processNotify
// [670] processGroupNotify
// [671] processIdle
// [672] processMisc
// [673] processRetryableOrder
// [674] create_task
// [675] get_target_task
// [676] is_attack_task
// [677] check_task
//
// Member Layout:
// ----------------------------------------------------------------

// Function: TribeLionUnitAIModule
// Address: 005042e0
TribeLionUnitAIModule * __thiscall
TribeLionUnitAIModule::TribeLionUnitAIModule
          (TribeLionUnitAIModule *this,RGE_Static_Object *param_1,int param_2)
{
  undefined4 *puVar1;
  undefined4 *unaff_FS_OFFSET;
  undefined4 local_c;
  code *pcStack_8;
  undefined4 local_4;
  
  local_4 = 0xffffffff;
  pcStack_8 = FUN_00560c48;
  local_c = *unaff_FS_OFFSET;
  *unaff_FS_OFFSET = &local_c;
  UnitAIModule::UnitAIModule((UnitAIModule *)this,param_1,param_2);
  local_4 = 0;
  *(undefined ***)this = &_vftable_;
  *(undefined4 *)&this->field_0x128 = 0x11;
  puVar1 = (undefined4 *)operator_new(0x44);
  *(undefined4 **)&this->field_0x124 = puVar1;
  if (puVar1 != (undefined4 *)0x0) {
    *puVar1 = 0x1d;
    *(undefined4 *)(*(int *)&this->field_0x124 + 4) = 9;
    *(undefined4 *)(*(int *)&this->field_0x124 + 8) = 0;
    *(undefined4 *)(*(int *)&this->field_0x124 + 0xc) = 4;
    *(undefined4 *)(*(int *)&this->field_0x124 + 0x10) = 0x1a;
    *(undefined4 *)(*(int *)&this->field_0x124 + 0x14) = 0x18;
    *(undefined4 *)(*(int *)&this->field_0x124 + 0x18) = 6;
    *(undefined4 *)(*(int *)&this->field_0x124 + 0x1c) = 0x19;
    *(undefined4 *)(*(int *)&this->field_0x124 + 0x20) = 0x11;
    *(undefined4 *)(*(int *)&this->field_0x124 + 0x24) = 0xd;
    *(undefined4 *)(*(int *)&this->field_0x124 + 0x28) = 0xc;
    *(undefined4 *)(*(int *)&this->field_0x124 + 0x2c) = 0x23;
    *(undefined4 *)(*(int *)&this->field_0x124 + 0x30) = 0x17;
    *(undefined4 *)(*(int *)&this->field_0x124 + 0x34) = 0x24;
    *(undefined4 *)(*(int *)&this->field_0x124 + 0x38) = 0x1c;
    *(undefined4 *)(*(int *)&this->field_0x124 + 0x3c) = 0x12;
    *(undefined4 *)(*(int *)&this->field_0x124 + 0x40) = 0x27;
  }
  *(undefined4 *)&this->field_0x100 = 6000;
  UnitAIModule::setAdjustedIdleTimeout((UnitAIModule *)this);
  *unaff_FS_OFFSET = local_c;
  return this;
}

// --------------------------------------------------

// Function: `vector_deleting_destructor'
// Address: 00504440
void * __thiscall
TribeLionUnitAIModule::_vector_deleting_destructor_(TribeLionUnitAIModule *this,uint param_1)
{
  ~TribeLionUnitAIModule(this);
  if ((param_1 & 1) != 0) {
    operator_delete(this);
  }
  return this;
}

// --------------------------------------------------

// Function: ~TribeLionUnitAIModule
// Address: 00504460
void __thiscall TribeLionUnitAIModule::~TribeLionUnitAIModule(TribeLionUnitAIModule *this)
{
  undefined4 *unaff_FS_OFFSET;
  undefined4 uStack_c;
  code *pcStack_8;
  undefined4 uStack_4;
  
  pcStack_8 = FUN_0055c8ab;
  uStack_c = *unaff_FS_OFFSET;
  *unaff_FS_OFFSET = &uStack_c;
  *(undefined ***)this = &UnitAIModule::_vftable_;
  uStack_4 = 0;
  if (*(void **)&this->field_0x18 != (void *)0x0) {
    operator_delete(*(void **)&this->field_0x18);
    *(undefined4 *)&this->field_0x18 = 0;
  }
  if (*(void **)&this->field_0x24 != (void *)0x0) {
    operator_delete(*(void **)&this->field_0x24);
    *(undefined4 *)&this->field_0x24 = 0;
  }
  if (*(void **)&this->field_0x124 != (void *)0x0) {
    operator_delete(*(void **)&this->field_0x124);
    *(undefined4 *)&this->field_0x124 = 0;
  }
  if (*(void **)&this->field_0x12c != (void *)0x0) {
    operator_delete(*(void **)&this->field_0x12c);
    *(undefined4 *)&this->field_0x12c = 0;
  }
  uStack_4 = 0xffffffff;
  if (*(void **)&this->field_0x60 != (void *)0x0) {
    operator_delete(*(void **)&this->field_0x60);
    *(undefined4 *)&this->field_0x60 = 0;
  }
  *(undefined4 *)&this->field_0x64 = 0;
  *(undefined4 *)&this->field_0x68 = 0;
  *(undefined4 *)&this->field_0x6c = 0;
  *unaff_FS_OFFSET = uStack_c;
  return;
}

// --------------------------------------------------

// Function: canAttackUnitAtNeutrality
// Address: 00504470
int __thiscall
TribeLionUnitAIModule::canAttackUnitAtNeutrality(TribeLionUnitAIModule *this,int param_1)
{
  return 1;
}

// --------------------------------------------------

// Function: processNotify
// Address: 00504480
// [HELPER] s_C__msdev_work_age1_x1_taiuaimd_c: "C:\msdev\work\age1_x1\taiuaimd.cpp"
// [HELPER] s___d_call_stopObject__s__d_: "#%d call stopObject %s %d\n"
int __thiscall
TribeLionUnitAIModule::processNotify(TribeLionUnitAIModule *this,NotifyEvent *param_1,ulong param_2)
{
  RGE_Static_Object *pRVar1;
  undefined4 uVar2;
  int iVar3;
  float fVar4;
  ulong unaff_retaddr;
  
  if (param_1->mType != 0x1fa) {
    if (param_1->mType == 0x1fc) {
      pRVar1 = RGE_Game_World::object
                         (*(RGE_Game_World **)(*(int *)(*(int *)&this->field_0x4 + 0xc) + 0x3c),
                          *(int *)&this->field_0x34);
      if (pRVar1 != (RGE_Static_Object *)0x0) {
        fVar4 = RGE_Static_Object::distance_to_object
                          (*(RGE_Static_Object **)&this->field_0x4,pRVar1);
        if (fVar4 <= *(float *)(*(int *)(*(int *)&this->field_0x4 + 8) + 0x28)) {
          (**(code **)(*(int *)this + 0x5c))(*(undefined4 *)&this->field_0x34,1);
          return 3;
        }
      }
      UnitAIModule::removeCurrentTarget((UnitAIModule *)this);
      if (actionFile != (_iobuf *)0x0) {
        if (*(int *)&this->field_0x4 == 0) {
          uVar2 = 0xffffffff;
        }
        else {
          uVar2 = *(undefined4 *)(*(int *)&this->field_0x4 + 4);
        }
        fprintf(actionFile,s___d_call_stopObject__s__d_,uVar2,s_C__msdev_work_age1_x1_taiuaimd_c,
                0x1ac);
      }
      iVar3 = *(int *)this;
      (**(code **)(iVar3 + 0x58))(1);
      (**(code **)(iVar3 + 0x1c))(param_1);
      iVar3 = UnitAIModule::processNotify((UnitAIModule *)this,param_1,unaff_retaddr);
      return iVar3;
    }
    goto LAB_005045ea;
  }
  if (param_1->p1 != 600) goto LAB_005045ea;
  iVar3 = RGE_Base_Game::scenarioGame(rge_base_game);
  if (iVar3 == 1) {
    iVar3 = RGE_Base_Game::singlePlayerGame(rge_base_game);
    if (iVar3 != 1) goto LAB_00504597;
    iVar3 = RGE_Game_World::difficultyLevel
                      (*(RGE_Game_World **)(*(int *)(*(int *)&this->field_0x4 + 0xc) + 0x3c));
    *(int *)&this->field_0x100 = (iVar3 + 3) * 5000;
  }
  else {
LAB_00504597:
    *(undefined4 *)&this->field_0x100 = 25000;
  }
  UnitAIModule::setAdjustedIdleTimeout((UnitAIModule *)this);
  UnitAIModule::removeCurrentTarget((UnitAIModule *)this);
  if (actionFile != (_iobuf *)0x0) {
    if (*(int *)&this->field_0x4 == 0) {
      uVar2 = 0xffffffff;
    }
    else {
      uVar2 = *(undefined4 *)(*(int *)&this->field_0x4 + 4);
    }
    fprintf(actionFile,s___d_call_stopObject__s__d_,uVar2,s_C__msdev_work_age1_x1_taiuaimd_c,0x191);
  }
  (**(code **)(*(int *)this + 0x58))(1);
LAB_005045ea:
  iVar3 = UnitAIModule::processNotify((UnitAIModule *)this,param_1,param_2);
  return iVar3;
}

// --------------------------------------------------

// Function: processIdle
// Address: 00504600
int __thiscall TribeLionUnitAIModule::processIdle(TribeLionUnitAIModule *this,int param_1)
{
  int iVar1;
  int iVar2;
  RGE_Static_Object *pRVar3;
  int iVar4;
  int iVar5;
  RGE_Static_Object *this_00;
  float fVar6;
  float fVar7;
  float maxReactDistance;
  RGE_Static_Object *newTarget;
  
  *(undefined4 *)&this->field_0x100 = 6000;
  UnitAIModule::setAdjustedIdleTimeout((UnitAIModule *)this);
  iVar1 = *(int *)this;
  iVar2 = (**(code **)(iVar1 + 0x40))(0xffffffff,0xffffffff,0xffffffff,0xffffffff,0);
  pRVar3 = UnitAIModule::lookupObject((UnitAIModule *)this,iVar2);
  if ((iVar2 != -1) && (pRVar3 != (RGE_Static_Object *)0x0)) {
    iVar4 = RGE_Game_World::difficultyLevel
                      (*(RGE_Game_World **)(*(int *)(*(int *)&this->field_0x4 + 0xc) + 0x3c));
    iVar5 = RGE_Base_Game::scenarioGame(rge_base_game);
    if ((iVar5 == 1) &&
       ((iVar5 = RGE_Base_Game::singlePlayerGame(rge_base_game), iVar5 == 1 && (2 < iVar4)))) {
      fVar7 = _DAT_005758b8;
      if (iVar4 == 3) {
        fVar7 = _DAT_005758b4;
      }
      this_00 = *(RGE_Static_Object **)&this->field_0x4;
      fVar7 = fVar7 * this_00->master_obj->los;
      if (fVar7 < _DAT_005758bc) {
        fVar7 = 1.0;
      }
    }
    else {
      this_00 = *(RGE_Static_Object **)&this->field_0x4;
      fVar7 = this_00->master_obj->los;
      fVar7 = fVar7 + fVar7;
    }
    fVar6 = RGE_Static_Object::distance_to_object(this_00,pRVar3);
    if (fVar6 <= fVar7) {
      (**(code **)(iVar1 + 0x5c))(iVar2,0);
      return 6;
    }
  }
  return 5;
}

// --------------------------------------------------

