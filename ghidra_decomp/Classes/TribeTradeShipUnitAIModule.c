// Class: TribeTradeShipUnitAIModule
// Size:  0x134
//
// VTable Layout:
// [00] `scalar_deleting_destructor'
// [01] save
// [02] load
// [03] owner
// [04] order
// [05] notify
// [06] notifyCommander
// [07] notifyCommander
// [08] search
// [09] importantWhenDead
// [10] retryableOrder
// [11] actionRequiresLiveTarget
// [12] bestUnitToAttack
// [13] mostDangerousEnemy
// [14] weakestEnemy
// [15] closestAttacker
// [16] closestObject
// [17] closestResourceObject
// [18] closestUndiscoveredTile
// [19] logDebug
// [20] canAttackUnit
// [21] canAttackUnitAtNeutrality
// [22] stopObject
// [23] attackObject
// [24] attackRoundupObject
// [25] huntObject
// [26] gatherObject
// [27] convertObject
// [28] healObject
// [29] repairObject
// [30] buildObject
// [31] tradeWithObject
// [32] explore
// [33] enterObject
// [34] unload
// [35] transportObject
// [36] moveTo
// [37] moveTo
// [38] moveTo
// [39] evasiveMoveTo
// [40] intelligentEvasiveMoveTo
// [41] runAwayFromAttackers
// [42] followObject
// [43] defendObject
// [44] defendPosition
// [45] seekAndDestroy
// [46] exploreAndDestroy
// [47] importantObject
// [48] convertToLOSResourceType
// [49] canConvert
// [50] processOrder
// [51] processNotify
// [52] processGroupNotify
// [53] processIdle
// [54] processMisc
// [55] processRetryableOrder
// [56] `scalar_deleting_destructor'
// [57] save
// [58] load
// [59] owner
// [60] order
// [61] notify
// [62] notifyCommander
// [63] notifyCommander
// [64] search
// [65] importantWhenDead
// [66] retryableOrder
// [67] actionRequiresLiveTarget
// [68] bestUnitToAttack
// [69] mostDangerousEnemy
// [70] weakestEnemy
// [71] closestAttacker
// [72] closestObject
// [73] closestResourceObject
// [74] closestUndiscoveredTile
// [75] logDebug
// [76] canAttackUnit
// [77] canAttackUnitAtNeutrality
// [78] stopObject
// [79] attackObject
// [80] attackRoundupObject
// [81] huntObject
// [82] gatherObject
// [83] convertObject
// [84] healObject
// [85] repairObject
// [86] buildObject
// [87] tradeWithObject
// [88] explore
// [89] enterObject
// [90] unload
// [91] transportObject
// [92] moveTo
// [93] moveTo
// [94] moveTo
// [95] evasiveMoveTo
// [96] intelligentEvasiveMoveTo
// [97] runAwayFromAttackers
// [98] followObject
// [99] defendObject
// [100] defendPosition
// [101] seekAndDestroy
// [102] exploreAndDestroy
// [103] importantObject
// [104] convertToLOSResourceType
// [105] canConvert
// [106] processOrder
// [107] processNotify
// [108] processGroupNotify
// [109] processIdle
// [110] processMisc
// [111] processRetryableOrder
// [112] `scalar_deleting_destructor'
// [113] save
// [114] load
// [115] owner
// [116] order
// [117] notify
// [118] notifyCommander
// [119] notifyCommander
// [120] search
// [121] importantWhenDead
// [122] retryableOrder
// [123] actionRequiresLiveTarget
// [124] bestUnitToAttack
// [125] mostDangerousEnemy
// [126] weakestEnemy
// [127] closestAttacker
// [128] closestObject
// [129] closestResourceObject
// [130] closestUndiscoveredTile
// [131] logDebug
// [132] canAttackUnit
// [133] canAttackUnitAtNeutrality
// [134] stopObject
// [135] attackObject
// [136] attackRoundupObject
// [137] huntObject
// [138] gatherObject
// [139] convertObject
// [140] healObject
// [141] repairObject
// [142] buildObject
// [143] tradeWithObject
// [144] explore
// [145] enterObject
// [146] unload
// [147] transportObject
// [148] moveTo
// [149] moveTo
// [150] moveTo
// [151] evasiveMoveTo
// [152] intelligentEvasiveMoveTo
// [153] runAwayFromAttackers
// [154] followObject
// [155] defendObject
// [156] defendPosition
// [157] seekAndDestroy
// [158] exploreAndDestroy
// [159] importantObject
// [160] convertToLOSResourceType
// [161] canConvert
// [162] processOrder
// [163] processNotify
// [164] processGroupNotify
// [165] processIdle
// [166] processMisc
// [167] processRetryableOrder
// [168] `scalar_deleting_destructor'
// [169] save
// [170] load
// [171] owner
// [172] order
// [173] notify
// [174] notifyCommander
// [175] notifyCommander
// [176] search
// [177] importantWhenDead
// [178] retryableOrder
// [179] actionRequiresLiveTarget
// [180] bestUnitToAttack
// [181] mostDangerousEnemy
// [182] weakestEnemy
// [183] closestAttacker
// [184] closestObject
// [185] closestResourceObject
// [186] closestUndiscoveredTile
// [187] logDebug
// [188] canAttackUnit
// [189] canAttackUnitAtNeutrality
// [190] stopObject
// [191] attackObject
// [192] attackRoundupObject
// [193] huntObject
// [194] gatherObject
// [195] convertObject
// [196] healObject
// [197] repairObject
// [198] buildObject
// [199] tradeWithObject
// [200] explore
// [201] enterObject
// [202] unload
// [203] transportObject
// [204] moveTo
// [205] moveTo
// [206] moveTo
// [207] evasiveMoveTo
// [208] intelligentEvasiveMoveTo
// [209] runAwayFromAttackers
// [210] followObject
// [211] defendObject
// [212] defendPosition
// [213] seekAndDestroy
// [214] exploreAndDestroy
// [215] importantObject
// [216] convertToLOSResourceType
// [217] canConvert
// [218] processOrder
// [219] processNotify
// [220] processGroupNotify
// [221] processIdle
// [222] processMisc
// [223] processRetryableOrder
// [224] `vector_deleting_destructor'
// [225] save
// [226] load
// [227] owner
// [228] order
// [229] notify
// [230] notifyCommander
// [231] notifyCommander
// [232] search
// [233] importantWhenDead
// [234] retryableOrder
// [235] actionRequiresLiveTarget
// [236] bestUnitToAttack
// [237] mostDangerousEnemy
// [238] weakestEnemy
// [239] closestAttacker
// [240] closestObject
// [241] closestResourceObject
// [242] closestUndiscoveredTile
// [243] logDebug
// [244] canAttackUnit
// [245] canAttackUnitAtNeutrality
// [246] stopObject
// [247] attackObject
// [248] attackRoundupObject
// [249] huntObject
// [250] gatherObject
// [251] convertObject
// [252] healObject
// [253] repairObject
// [254] buildObject
// [255] tradeWithObject
// [256] explore
// [257] enterObject
// [258] unload
// [259] transportObject
// [260] moveTo
// [261] moveTo
// [262] moveTo
// [263] evasiveMoveTo
// [264] intelligentEvasiveMoveTo
// [265] runAwayFromAttackers
// [266] followObject
// [267] defendObject
// [268] defendPosition
// [269] seekAndDestroy
// [270] exploreAndDestroy
// [271] importantObject
// [272] convertToLOSResourceType
// [273] canConvert
// [274] processOrder
// [275] processNotify
// [276] processGroupNotify
// [277] processIdle
// [278] processMisc
// [279] processRetryableOrder
// [280] `scalar_deleting_destructor'
// [281] save
// [282] load
// [283] owner
// [284] order
// [285] notify
// [286] notifyCommander
// [287] notifyCommander
// [288] search
// [289] importantWhenDead
// [290] retryableOrder
// [291] actionRequiresLiveTarget
// [292] bestUnitToAttack
// [293] mostDangerousEnemy
// [294] weakestEnemy
// [295] closestAttacker
// [296] closestObject
// [297] closestResourceObject
// [298] closestUndiscoveredTile
// [299] logDebug
// [300] canAttackUnit
// [301] canAttackUnitAtNeutrality
// [302] stopObject
// [303] attackObject
// [304] attackRoundupObject
// [305] huntObject
// [306] gatherObject
// [307] convertObject
// [308] healObject
// [309] repairObject
// [310] buildObject
// [311] tradeWithObject
// [312] explore
// [313] enterObject
// [314] unload
// [315] transportObject
// [316] moveTo
// [317] moveTo
// [318] moveTo
// [319] evasiveMoveTo
// [320] intelligentEvasiveMoveTo
// [321] runAwayFromAttackers
// [322] followObject
// [323] defendObject
// [324] defendPosition
// [325] seekAndDestroy
// [326] exploreAndDestroy
// [327] importantObject
// [328] convertToLOSResourceType
// [329] canConvert
// [330] processOrder
// [331] processNotify
// [332] processGroupNotify
// [333] processIdle
// [334] processMisc
// [335] processRetryableOrder
// [336] `scalar_deleting_destructor'
// [337] save
// [338] load
// [339] owner
// [340] order
// [341] notify
// [342] notifyCommander
// [343] notifyCommander
// [344] search
// [345] importantWhenDead
// [346] retryableOrder
// [347] actionRequiresLiveTarget
// [348] bestUnitToAttack
// [349] mostDangerousEnemy
// [350] weakestEnemy
// [351] closestAttacker
// [352] closestObject
// [353] closestResourceObject
// [354] closestUndiscoveredTile
// [355] logDebug
// [356] canAttackUnit
// [357] canAttackUnitAtNeutrality
// [358] stopObject
// [359] attackObject
// [360] attackRoundupObject
// [361] huntObject
// [362] gatherObject
// [363] convertObject
// [364] healObject
// [365] repairObject
// [366] buildObject
// [367] tradeWithObject
// [368] explore
// [369] enterObject
// [370] unload
// [371] transportObject
// [372] moveTo
// [373] moveTo
// [374] moveTo
// [375] evasiveMoveTo
// [376] intelligentEvasiveMoveTo
// [377] runAwayFromAttackers
// [378] followObject
// [379] defendObject
// [380] defendPosition
// [381] seekAndDestroy
// [382] exploreAndDestroy
// [383] importantObject
// [384] convertToLOSResourceType
// [385] canConvert
// [386] processOrder
// [387] processNotify
// [388] processGroupNotify
// [389] processIdle
// [390] processMisc
// [391] processRetryableOrder
// [392] create_task
// [393] get_target_task
// [394] is_attack_task
// [395] check_task
//
// Member Layout:
// ----------------------------------------------------------------

// Function: TribeTradeShipUnitAIModule
// Address: 00506240
TribeTradeShipUnitAIModule * __thiscall
TribeTradeShipUnitAIModule::TribeTradeShipUnitAIModule
          (TribeTradeShipUnitAIModule *this,RGE_Static_Object *param_1,int param_2)
{
  undefined4 *puVar1;
  undefined4 *unaff_FS_OFFSET;
  undefined4 local_c;
  code *pcStack_8;
  undefined4 local_4;
  
  local_4 = 0xffffffff;
  pcStack_8 = FUN_00560ca8;
  local_c = *unaff_FS_OFFSET;
  *unaff_FS_OFFSET = &local_c;
  UnitAIModule::UnitAIModule((UnitAIModule *)this,param_1,param_2);
  local_4 = 0;
  *(undefined ***)this = &_vftable_;
  *(undefined4 *)&this->field_0x128 = 5;
  puVar1 = (undefined4 *)operator_new(0x14);
  *(undefined4 **)&this->field_0x124 = puVar1;
  if (puVar1 != (undefined4 *)0x0) {
    *puVar1 = 3;
    *(undefined4 *)(*(int *)&this->field_0x124 + 4) = 0x16;
    *(undefined4 *)(*(int *)&this->field_0x124 + 8) = 0x14;
    *(undefined4 *)(*(int *)&this->field_0x124 + 0xc) = 2;
    *(undefined4 *)(*(int *)&this->field_0x124 + 0x10) = 0x15;
  }
  *unaff_FS_OFFSET = local_c;
  return this;
}

// --------------------------------------------------

// Function: `scalar_deleting_destructor'
// Address: 005062f0
void * __thiscall
TribeTradeShipUnitAIModule::_scalar_deleting_destructor_
          (TribeTradeShipUnitAIModule *this,uint param_1)
{
  ~TribeTradeShipUnitAIModule(this);
  if ((param_1 & 1) != 0) {
    operator_delete(this);
  }
  return this;
}

// --------------------------------------------------

// Function: ~TribeTradeShipUnitAIModule
// Address: 00506310
void __thiscall
TribeTradeShipUnitAIModule::~TribeTradeShipUnitAIModule(TribeTradeShipUnitAIModule *this)
{
  undefined4 *unaff_FS_OFFSET;
  undefined4 uStack_c;
  code *pcStack_8;
  undefined4 uStack_4;
  
  pcStack_8 = FUN_0055c8ab;
  uStack_c = *unaff_FS_OFFSET;
  *unaff_FS_OFFSET = &uStack_c;
  *(undefined ***)this = &UnitAIModule::_vftable_;
  uStack_4 = 0;
  if (*(void **)&this->field_0x18 != (void *)0x0) {
    operator_delete(*(void **)&this->field_0x18);
    *(undefined4 *)&this->field_0x18 = 0;
  }
  if (*(void **)&this->field_0x24 != (void *)0x0) {
    operator_delete(*(void **)&this->field_0x24);
    *(undefined4 *)&this->field_0x24 = 0;
  }
  if (*(void **)&this->field_0x124 != (void *)0x0) {
    operator_delete(*(void **)&this->field_0x124);
    *(undefined4 *)&this->field_0x124 = 0;
  }
  if (*(void **)&this->field_0x12c != (void *)0x0) {
    operator_delete(*(void **)&this->field_0x12c);
    *(undefined4 *)&this->field_0x12c = 0;
  }
  uStack_4 = 0xffffffff;
  if (*(void **)&this->field_0x60 != (void *)0x0) {
    operator_delete(*(void **)&this->field_0x60);
    *(undefined4 *)&this->field_0x60 = 0;
  }
  *(undefined4 *)&this->field_0x64 = 0;
  *(undefined4 *)&this->field_0x68 = 0;
  *(undefined4 *)&this->field_0x6c = 0;
  *unaff_FS_OFFSET = uStack_c;
  return;
}

// --------------------------------------------------

// Function: processNotify
// Address: 00506320
// [HELPER] s_C__msdev_work_age1_x1_taiuaimd_c: "C:\msdev\work\age1_x1\taiuaimd.cpp"
// [HELPER] s___d_call_stopObject__s__d_: "#%d call stopObject %s %d\n"
int __thiscall
TribeTradeShipUnitAIModule::processNotify
          (TribeTradeShipUnitAIModule *this,NotifyEvent *param_1,ulong param_2)
{
  code *pcVar1;
  NotifyEvent *pNVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  void *pvVar6;
  undefined4 uVar7;
  ulong unaff_EDI;
  undefined4 uVar8;
  
  pNVar2 = param_1;
  iVar3 = param_1->mType;
  if (iVar3 != 500) {
    if (iVar3 == 0x202) {
      if (*(int *)&this->field_0x30 == 0x267) {
        iVar3 = *(int *)this;
        pcVar1 = *(code **)(iVar3 + 0x40);
        iVar4 = (*pcVar1)(0xffffffff,0,2,0x2d,0);
        if (iVar4 != -1) {
          iVar4 = (**(code **)(iVar3 + 0x7c))(iVar4,1);
          if (iVar4 == 1) {
            return 6;
          }
        }
        iVar4 = (*pcVar1)(0xffffffff,1,2,0x2d,0);
        if (iVar4 != -1) {
          iVar3 = (**(code **)(iVar3 + 0x7c))(iVar4,1);
          if (iVar3 == 1) {
            return 6;
          }
        }
        goto LAB_00506485;
      }
      if (*(int *)&this->field_0x30 != 0x25d) goto LAB_00506485;
      iVar3 = *(int *)this;
      iVar4 = (**(code **)(iVar3 + 0x48))(&param_1,&param_2,1);
      if (iVar4 == 1) {
        UnitAIModule::addToWaypointQueue((UnitAIModule *)this,(int)param_1,param_2);
        iVar4 = (**(code **)(iVar3 + 0x80))(param_1,param_2,1);
        if (iVar4 != 0) goto LAB_00506485;
        UnitAIModule::removeCurrentTarget((UnitAIModule *)this);
        if (actionFile != (_iobuf *)0x0) {
          if (*(int *)&this->field_0x4 == 0) {
            uVar7 = 0xffffffff;
            uVar8 = 0x79c;
          }
          else {
            uVar7 = *(undefined4 *)(*(int *)&this->field_0x4 + 4);
            uVar8 = 0x79c;
          }
          goto LAB_00506464;
        }
      }
      else {
        UnitAIModule::removeCurrentTarget((UnitAIModule *)this);
        if (actionFile != (_iobuf *)0x0) {
          if (*(int *)&this->field_0x4 == 0) {
            uVar7 = 0xffffffff;
          }
          else {
            uVar7 = *(undefined4 *)(*(int *)&this->field_0x4 + 4);
          }
          uVar8 = 0x7a8;
LAB_00506464:
          fprintf(actionFile,s___d_call_stopObject__s__d_,uVar7,s_C__msdev_work_age1_x1_taiuaimd_c,
                  uVar8);
        }
      }
      (**(code **)(iVar3 + 0x58))(1);
      (**(code **)(iVar3 + 0x1c))(pNVar2);
LAB_00506485:
      UnitAIModule::removeCurrentTarget((UnitAIModule *)this);
      if (actionFile != (_iobuf *)0x0) {
        if (*(int *)&this->field_0x4 == 0) {
          uVar7 = 0xffffffff;
        }
        else {
          uVar7 = *(undefined4 *)(*(int *)&this->field_0x4 + 4);
        }
        fprintf(actionFile,s___d_call_stopObject__s__d_,uVar7,s_C__msdev_work_age1_x1_taiuaimd_c,
                0x7b0);
      }
      iVar3 = *(int *)this;
      (**(code **)(iVar3 + 0x58))(1);
      (**(code **)(iVar3 + 0x1c))(pNVar2);
      return 2;
    }
    if (iVar3 != 0x20f) {
      iVar3 = UnitAIModule::processNotify((UnitAIModule *)this,param_1,param_2);
      return iVar3;
    }
  }
  if (param_1->p2 < 1) {
    uVar7 = *(undefined4 *)(*(int *)&this->field_0x4 + 4);
    (**(code **)(**(int **)(*(int *)&this->field_0x4 + 0xc) + 0xe8))
              (uVar7,uVar7,0x209,param_1->caller,0,0);
    UnitAIModule::purgeNotifyQueue((UnitAIModule *)this,unaff_EDI);
    return 4;
  }
  if (*(int *)&this->field_0x64 != 0) {
    iVar3 = RGE_Player::computerPlayer(*(RGE_Player **)(*(int *)&this->field_0x4 + 0xc));
    if (iVar3 != 1) goto LAB_0050654f;
  }
  uVar7 = *(undefined4 *)(*(int *)&this->field_0x4 + 4);
  (**(code **)(**(int **)(*(int *)&this->field_0x4 + 0xc) + 0xe8))
            (uVar7,uVar7,0x201,pNVar2->caller,0,0);
LAB_0050654f:
  iVar3 = 0;
  if (0 < *(int *)&this->field_0x64) {
    do {
      if (*(int *)&this->field_0x6c <= iVar3) break;
      if (*(int *)(*(int *)&this->field_0x60 + iVar3 * 4) == pNVar2->caller) goto LAB_00506592;
      iVar3 = iVar3 + 1;
    } while (iVar3 < *(int *)&this->field_0x64);
  }
  iVar3 = RGE_Player::computerPlayer(*(RGE_Player **)(*(int *)&this->field_0x4 + 0xc));
  if ((iVar3 == 0) && (*(int *)&this->field_0x34 != pNVar2->caller)) {
    UnitAIModule::askForHelp((UnitAIModule *)this,pNVar2->caller);
  }
LAB_00506592:
  iVar3 = *(int *)&this->field_0x64;
  iVar4 = pNVar2->caller;
  iVar5 = 0;
  if (0 < iVar3) {
    do {
      if (*(int *)&this->field_0x6c <= iVar5) break;
      if (*(int *)(*(int *)&this->field_0x60 + iVar5 * 4) == iVar4) goto LAB_00506615;
      iVar5 = iVar5 + 1;
    } while (iVar5 < iVar3);
  }
  if (*(int *)&this->field_0x6c + -1 < iVar3) {
    iVar3 = iVar3 + 1;
    pvVar6 = operator_new(iVar3 * 4);
    if (pvVar6 != (void *)0x0) {
      iVar5 = 0;
      if (0 < *(int *)&this->field_0x6c) {
        do {
          if (iVar3 <= iVar5) break;
          iVar5 = iVar5 + 1;
          *(undefined4 *)((int)pvVar6 + iVar5 * 4 + -4) =
               *(undefined4 *)(*(int *)&this->field_0x60 + -4 + iVar5 * 4);
        } while (iVar5 < *(int *)&this->field_0x6c);
      }
      operator_delete(*(void **)&this->field_0x60);
      *(void **)&this->field_0x60 = pvVar6;
      *(int *)&this->field_0x6c = iVar3;
    }
  }
  *(int *)(*(int *)&this->field_0x60 + *(int *)&this->field_0x64 * 4) = iVar4;
  *(int *)&this->field_0x64 = *(int *)&this->field_0x64 + 1;
LAB_00506615:
  (**(code **)(**(int **)&this->field_0x4 + 0xec))(1);
  iVar3 = RGE_Player::computerPlayer(*(RGE_Player **)(*(int *)&this->field_0x4 + 0xc));
  if ((iVar3 == 0) && (*(int *)&this->field_0x28 != -1)) {
    return 2;
  }
  if (*(int *)&this->field_0x30 != 0x262) {
    iVar3 = *(int *)this;
    (**(code **)(iVar3 + 0x10))
              (*(undefined4 *)(*(int *)&this->field_0x4 + 4),*(undefined4 *)&this->field_0x28,
               *(undefined4 *)&this->field_0x34,0xffffffff,*(undefined4 *)&this->field_0x3c,
               *(undefined4 *)&this->field_0x40,*(undefined4 *)&this->field_0x44,
               *(undefined4 *)&this->field_0x48,0,0,*(undefined4 *)&this->field_0x2c);
    if (actionFile != (_iobuf *)0x0) {
      if (*(int *)&this->field_0x4 == 0) {
        uVar7 = 0xffffffff;
      }
      else {
        uVar7 = *(undefined4 *)(*(int *)&this->field_0x4 + 4);
      }
      fprintf(actionFile,s___d_call_stopObject__s__d_,uVar7,s_C__msdev_work_age1_x1_taiuaimd_c,0x761
             );
    }
    (**(code **)(iVar3 + 0x58))(1);
  }
  (**(code **)(*(int *)this + 0xa4))(1);
  return 3;
}

// --------------------------------------------------

// Function: processIdle
// Address: 005066d0
int __thiscall TribeTradeShipUnitAIModule::processIdle(TribeTradeShipUnitAIModule *this,int param_1)
{
  float fVar1;
  float fVar2;
  float fVar3;
  int iVar4;
  int iVar5;
  RGE_Static_Object *pRVar6;
  float10 fVar7;
  float yDiff;
  float xDiff;
  
  iVar4 = RGE_Player::computerPlayer(*(RGE_Player **)(*(int *)&this->field_0x4 + 0xc));
  if (iVar4 != 0) {
    iVar4 = *(int *)this;
    iVar5 = (**(code **)(iVar4 + 0x40))(0xffffffff,0xffffffff,0xffffffff,0xffffffff,0);
    if (iVar5 != -1) {
      pRVar6 = RGE_Game_World::object
                         (*(RGE_Game_World **)(*(int *)(*(int *)&this->field_0x4 + 0xc) + 0x3c),
                          iVar5);
      if (pRVar6 != (RGE_Static_Object *)0x0) {
        fVar7 = (float10)(**(code **)(**(int **)&this->field_0x4 + 0xfc))();
        iVar5 = *(int *)&this->field_0x4;
        fVar3 = pRVar6->world_x - *(float *)(iVar5 + 0x38);
        fVar1 = pRVar6->world_y - *(float *)(iVar5 + 0x3c);
        fVar2 = SQRT(fVar1 * fVar1 + fVar3 * fVar3);
        (**(code **)(iVar4 + 0x9c))
                  (-((fVar3 / fVar2) * (float)(fVar7 * (float10)_DAT_005758d8)) +
                   *(float *)(iVar5 + 0x38),
                   -((fVar1 / fVar2) * (float)(fVar7 * (float10)_DAT_005758d8)) +
                   *(float *)(iVar5 + 0x3c),*(undefined4 *)(iVar5 + 0x40),1);
        return 6;
      }
    }
  }
  return 5;
}

// --------------------------------------------------

