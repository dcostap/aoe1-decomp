// Class: TribePriestUnitAIModule
// Size:  0x134
//
// VTable Layout:
// [00] `vector_deleting_destructor'
// [01] save
// [02] load
// [03] owner
// [04] order
// [05] notify
// [06] notifyCommander
// [07] notifyCommander
// [08] search
// [09] importantWhenDead
// [10] retryableOrder
// [11] actionRequiresLiveTarget
// [12] bestUnitToAttack
// [13] mostDangerousEnemy
// [14] weakestEnemy
// [15] closestAttacker
// [16] closestObject
// [17] closestResourceObject
// [18] closestUndiscoveredTile
// [19] logDebug
// [20] canAttackUnit
// [21] canAttackUnitAtNeutrality
// [22] stopObject
// [23] attackObject
// [24] attackRoundupObject
// [25] huntObject
// [26] gatherObject
// [27] convertObject
// [28] healObject
// [29] repairObject
// [30] buildObject
// [31] tradeWithObject
// [32] explore
// [33] enterObject
// [34] unload
// [35] transportObject
// [36] moveTo
// [37] moveTo
// [38] moveTo
// [39] evasiveMoveTo
// [40] intelligentEvasiveMoveTo
// [41] runAwayFromAttackers
// [42] followObject
// [43] defendObject
// [44] defendPosition
// [45] seekAndDestroy
// [46] exploreAndDestroy
// [47] importantObject
// [48] convertToLOSResourceType
// [49] canConvert
// [50] processOrder
// [51] processNotify
// [52] processGroupNotify
// [53] processIdle
// [54] processMisc
// [55] processRetryableOrder
// [56] bestUnitToHeal
// [57] bestUnitToConvert
// [58] `scalar_deleting_destructor'
// [59] save
// [60] load
// [61] owner
// [62] order
// [63] notify
// [64] notifyCommander
// [65] notifyCommander
// [66] search
// [67] importantWhenDead
// [68] retryableOrder
// [69] actionRequiresLiveTarget
// [70] bestUnitToAttack
// [71] mostDangerousEnemy
// [72] weakestEnemy
// [73] closestAttacker
// [74] closestObject
// [75] closestResourceObject
// [76] closestUndiscoveredTile
// [77] logDebug
// [78] canAttackUnit
// [79] canAttackUnitAtNeutrality
// [80] stopObject
// [81] attackObject
// [82] attackRoundupObject
// [83] huntObject
// [84] gatherObject
// [85] convertObject
// [86] healObject
// [87] repairObject
// [88] buildObject
// [89] tradeWithObject
// [90] explore
// [91] enterObject
// [92] unload
// [93] transportObject
// [94] moveTo
// [95] moveTo
// [96] moveTo
// [97] evasiveMoveTo
// [98] intelligentEvasiveMoveTo
// [99] runAwayFromAttackers
// [100] followObject
// [101] defendObject
// [102] defendPosition
// [103] seekAndDestroy
// [104] exploreAndDestroy
// [105] importantObject
// [106] convertToLOSResourceType
// [107] canConvert
// [108] processOrder
// [109] processNotify
// [110] processGroupNotify
// [111] processIdle
// [112] processMisc
// [113] processRetryableOrder
// [114] `scalar_deleting_destructor'
// [115] save
// [116] load
// [117] owner
// [118] order
// [119] notify
// [120] notifyCommander
// [121] notifyCommander
// [122] search
// [123] importantWhenDead
// [124] retryableOrder
// [125] actionRequiresLiveTarget
// [126] bestUnitToAttack
// [127] mostDangerousEnemy
// [128] weakestEnemy
// [129] closestAttacker
// [130] closestObject
// [131] closestResourceObject
// [132] closestUndiscoveredTile
// [133] logDebug
// [134] canAttackUnit
// [135] canAttackUnitAtNeutrality
// [136] stopObject
// [137] attackObject
// [138] attackRoundupObject
// [139] huntObject
// [140] gatherObject
// [141] convertObject
// [142] healObject
// [143] repairObject
// [144] buildObject
// [145] tradeWithObject
// [146] explore
// [147] enterObject
// [148] unload
// [149] transportObject
// [150] moveTo
// [151] moveTo
// [152] moveTo
// [153] evasiveMoveTo
// [154] intelligentEvasiveMoveTo
// [155] runAwayFromAttackers
// [156] followObject
// [157] defendObject
// [158] defendPosition
// [159] seekAndDestroy
// [160] exploreAndDestroy
// [161] importantObject
// [162] convertToLOSResourceType
// [163] canConvert
// [164] processOrder
// [165] processNotify
// [166] processGroupNotify
// [167] processIdle
// [168] processMisc
// [169] processRetryableOrder
// [170] `scalar_deleting_destructor'
// [171] save
// [172] load
// [173] owner
// [174] order
// [175] notify
// [176] notifyCommander
// [177] notifyCommander
// [178] search
// [179] importantWhenDead
// [180] retryableOrder
// [181] actionRequiresLiveTarget
// [182] bestUnitToAttack
// [183] mostDangerousEnemy
// [184] weakestEnemy
// [185] closestAttacker
// [186] closestObject
// [187] closestResourceObject
// [188] closestUndiscoveredTile
// [189] logDebug
// [190] canAttackUnit
// [191] canAttackUnitAtNeutrality
// [192] stopObject
// [193] attackObject
// [194] attackRoundupObject
// [195] huntObject
// [196] gatherObject
// [197] convertObject
// [198] healObject
// [199] repairObject
// [200] buildObject
// [201] tradeWithObject
// [202] explore
// [203] enterObject
// [204] unload
// [205] transportObject
// [206] moveTo
// [207] moveTo
// [208] moveTo
// [209] evasiveMoveTo
// [210] intelligentEvasiveMoveTo
// [211] runAwayFromAttackers
// [212] followObject
// [213] defendObject
// [214] defendPosition
// [215] seekAndDestroy
// [216] exploreAndDestroy
// [217] importantObject
// [218] convertToLOSResourceType
// [219] canConvert
// [220] processOrder
// [221] processNotify
// [222] processGroupNotify
// [223] processIdle
// [224] processMisc
// [225] processRetryableOrder
// [226] `scalar_deleting_destructor'
// [227] save
// [228] load
// [229] owner
// [230] order
// [231] notify
// [232] notifyCommander
// [233] notifyCommander
// [234] search
// [235] importantWhenDead
// [236] retryableOrder
// [237] actionRequiresLiveTarget
// [238] bestUnitToAttack
// [239] mostDangerousEnemy
// [240] weakestEnemy
// [241] closestAttacker
// [242] closestObject
// [243] closestResourceObject
// [244] closestUndiscoveredTile
// [245] logDebug
// [246] canAttackUnit
// [247] canAttackUnitAtNeutrality
// [248] stopObject
// [249] attackObject
// [250] attackRoundupObject
// [251] huntObject
// [252] gatherObject
// [253] convertObject
// [254] healObject
// [255] repairObject
// [256] buildObject
// [257] tradeWithObject
// [258] explore
// [259] enterObject
// [260] unload
// [261] transportObject
// [262] moveTo
// [263] moveTo
// [264] moveTo
// [265] evasiveMoveTo
// [266] intelligentEvasiveMoveTo
// [267] runAwayFromAttackers
// [268] followObject
// [269] defendObject
// [270] defendPosition
// [271] seekAndDestroy
// [272] exploreAndDestroy
// [273] importantObject
// [274] convertToLOSResourceType
// [275] canConvert
// [276] processOrder
// [277] processNotify
// [278] processGroupNotify
// [279] processIdle
// [280] processMisc
// [281] processRetryableOrder
// [282] `vector_deleting_destructor'
// [283] save
// [284] load
// [285] owner
// [286] order
// [287] notify
// [288] notifyCommander
// [289] notifyCommander
// [290] search
// [291] importantWhenDead
// [292] retryableOrder
// [293] actionRequiresLiveTarget
// [294] bestUnitToAttack
// [295] mostDangerousEnemy
// [296] weakestEnemy
// [297] closestAttacker
// [298] closestObject
// [299] closestResourceObject
// [300] closestUndiscoveredTile
// [301] logDebug
// [302] canAttackUnit
// [303] canAttackUnitAtNeutrality
// [304] stopObject
// [305] attackObject
// [306] attackRoundupObject
// [307] huntObject
// [308] gatherObject
// [309] convertObject
// [310] healObject
// [311] repairObject
// [312] buildObject
// [313] tradeWithObject
// [314] explore
// [315] enterObject
// [316] unload
// [317] transportObject
// [318] moveTo
// [319] moveTo
// [320] moveTo
// [321] evasiveMoveTo
// [322] intelligentEvasiveMoveTo
// [323] runAwayFromAttackers
// [324] followObject
// [325] defendObject
// [326] defendPosition
// [327] seekAndDestroy
// [328] exploreAndDestroy
// [329] importantObject
// [330] convertToLOSResourceType
// [331] canConvert
// [332] processOrder
// [333] processNotify
// [334] processGroupNotify
// [335] processIdle
// [336] processMisc
// [337] processRetryableOrder
// [338] `scalar_deleting_destructor'
// [339] save
// [340] load
// [341] owner
// [342] order
// [343] notify
// [344] notifyCommander
// [345] notifyCommander
// [346] search
// [347] importantWhenDead
// [348] retryableOrder
// [349] actionRequiresLiveTarget
// [350] bestUnitToAttack
// [351] mostDangerousEnemy
// [352] weakestEnemy
// [353] closestAttacker
// [354] closestObject
// [355] closestResourceObject
// [356] closestUndiscoveredTile
// [357] logDebug
// [358] canAttackUnit
// [359] canAttackUnitAtNeutrality
// [360] stopObject
// [361] attackObject
// [362] attackRoundupObject
// [363] huntObject
// [364] gatherObject
// [365] convertObject
// [366] healObject
// [367] repairObject
// [368] buildObject
// [369] tradeWithObject
// [370] explore
// [371] enterObject
// [372] unload
// [373] transportObject
// [374] moveTo
// [375] moveTo
// [376] moveTo
// [377] evasiveMoveTo
// [378] intelligentEvasiveMoveTo
// [379] runAwayFromAttackers
// [380] followObject
// [381] defendObject
// [382] defendPosition
// [383] seekAndDestroy
// [384] exploreAndDestroy
// [385] importantObject
// [386] convertToLOSResourceType
// [387] canConvert
// [388] processOrder
// [389] processNotify
// [390] processGroupNotify
// [391] processIdle
// [392] processMisc
// [393] processRetryableOrder
// [394] `scalar_deleting_destructor'
// [395] save
// [396] load
// [397] owner
// [398] order
// [399] notify
// [400] notifyCommander
// [401] notifyCommander
// [402] search
// [403] importantWhenDead
// [404] retryableOrder
// [405] actionRequiresLiveTarget
// [406] bestUnitToAttack
// [407] mostDangerousEnemy
// [408] weakestEnemy
// [409] closestAttacker
// [410] closestObject
// [411] closestResourceObject
// [412] closestUndiscoveredTile
// [413] logDebug
// [414] canAttackUnit
// [415] canAttackUnitAtNeutrality
// [416] stopObject
// [417] attackObject
// [418] attackRoundupObject
// [419] huntObject
// [420] gatherObject
// [421] convertObject
// [422] healObject
// [423] repairObject
// [424] buildObject
// [425] tradeWithObject
// [426] explore
// [427] enterObject
// [428] unload
// [429] transportObject
// [430] moveTo
// [431] moveTo
// [432] moveTo
// [433] evasiveMoveTo
// [434] intelligentEvasiveMoveTo
// [435] runAwayFromAttackers
// [436] followObject
// [437] defendObject
// [438] defendPosition
// [439] seekAndDestroy
// [440] exploreAndDestroy
// [441] importantObject
// [442] convertToLOSResourceType
// [443] canConvert
// [444] processOrder
// [445] processNotify
// [446] processGroupNotify
// [447] processIdle
// [448] processMisc
// [449] processRetryableOrder
// [450] create_task
// [451] get_target_task
// [452] is_attack_task
// [453] check_task
//
// Member Layout:
// ----------------------------------------------------------------

// Function: TribePriestUnitAIModule
// Address: 00505820
TribePriestUnitAIModule * __thiscall
TribePriestUnitAIModule::TribePriestUnitAIModule
          (TribePriestUnitAIModule *this,RGE_Static_Object *param_1,int param_2)
{
  undefined4 *puVar1;
  undefined4 *unaff_FS_OFFSET;
  undefined4 local_c;
  code *pcStack_8;
  undefined4 local_4;
  
  local_4 = 0xffffffff;
  pcStack_8 = FUN_00560c88;
  local_c = *unaff_FS_OFFSET;
  *unaff_FS_OFFSET = &local_c;
  UnitAIModule::UnitAIModule((UnitAIModule *)this,param_1,param_2);
  local_4 = 0;
  *(undefined ***)this = &_vftable_;
  *(undefined4 *)&this->field_0x128 = 0x11;
  puVar1 = (undefined4 *)operator_new(0x44);
  *(undefined4 **)&this->field_0x124 = puVar1;
  if (puVar1 != (undefined4 *)0x0) {
    *puVar1 = 3;
    *(undefined4 *)(*(int *)&this->field_0x124 + 4) = 0;
    *(undefined4 *)(*(int *)&this->field_0x124 + 8) = 4;
    *(undefined4 *)(*(int *)&this->field_0x124 + 0xc) = 0x1a;
    *(undefined4 *)(*(int *)&this->field_0x124 + 0x10) = 0x18;
    *(undefined4 *)(*(int *)&this->field_0x124 + 0x14) = 6;
    *(undefined4 *)(*(int *)&this->field_0x124 + 0x18) = 0x19;
    *(undefined4 *)(*(int *)&this->field_0x124 + 0x1c) = 0x11;
    *(undefined4 *)(*(int *)&this->field_0x124 + 0x20) = 10;
    *(undefined4 *)(*(int *)&this->field_0x124 + 0x24) = 0xc;
    *(undefined4 *)(*(int *)&this->field_0x124 + 0x28) = 0x23;
    *(undefined4 *)(*(int *)&this->field_0x124 + 0x2c) = 0x17;
    *(undefined4 *)(*(int *)&this->field_0x124 + 0x30) = 0x24;
    *(undefined4 *)(*(int *)&this->field_0x124 + 0x34) = 0x1c;
    *(undefined4 *)(*(int *)&this->field_0x124 + 0x38) = 0x12;
    *(undefined4 *)(*(int *)&this->field_0x124 + 0x3c) = 0xd;
    *(undefined4 *)(*(int *)&this->field_0x124 + 0x40) = 0x27;
  }
  *unaff_FS_OFFSET = local_c;
  return this;
}

// --------------------------------------------------

// Function: `vector_deleting_destructor'
// Address: 00505970
void * __thiscall
TribePriestUnitAIModule::_vector_deleting_destructor_(TribePriestUnitAIModule *this,uint param_1)
{
  ~TribePriestUnitAIModule(this);
  if ((param_1 & 1) != 0) {
    operator_delete(this);
  }
  return this;
}

// --------------------------------------------------

// Function: ~TribePriestUnitAIModule
// Address: 00505990
void __thiscall TribePriestUnitAIModule::~TribePriestUnitAIModule(TribePriestUnitAIModule *this)
{
  undefined4 *unaff_FS_OFFSET;
  undefined4 uStack_c;
  code *pcStack_8;
  undefined4 uStack_4;
  
  pcStack_8 = FUN_0055c8ab;
  uStack_c = *unaff_FS_OFFSET;
  *unaff_FS_OFFSET = &uStack_c;
  *(undefined ***)this = &UnitAIModule::_vftable_;
  uStack_4 = 0;
  if (*(void **)&this->field_0x18 != (void *)0x0) {
    operator_delete(*(void **)&this->field_0x18);
    *(undefined4 *)&this->field_0x18 = 0;
  }
  if (*(void **)&this->field_0x24 != (void *)0x0) {
    operator_delete(*(void **)&this->field_0x24);
    *(undefined4 *)&this->field_0x24 = 0;
  }
  if (*(void **)&this->field_0x124 != (void *)0x0) {
    operator_delete(*(void **)&this->field_0x124);
    *(undefined4 *)&this->field_0x124 = 0;
  }
  if (*(void **)&this->field_0x12c != (void *)0x0) {
    operator_delete(*(void **)&this->field_0x12c);
    *(undefined4 *)&this->field_0x12c = 0;
  }
  uStack_4 = 0xffffffff;
  if (*(void **)&this->field_0x60 != (void *)0x0) {
    operator_delete(*(void **)&this->field_0x60);
    *(undefined4 *)&this->field_0x60 = 0;
  }
  *(undefined4 *)&this->field_0x64 = 0;
  *(undefined4 *)&this->field_0x68 = 0;
  *(undefined4 *)&this->field_0x6c = 0;
  *unaff_FS_OFFSET = uStack_c;
  return;
}

// --------------------------------------------------

// Function: attackObject
// Address: 005059a0
int __thiscall
TribePriestUnitAIModule::attackObject(TribePriestUnitAIModule *this,int param_1,int param_2)
{
  int iVar1;
  int iVar2;
  float10 fVar3;
  
  iVar2 = *(int *)this;
  iVar1 = (**(code **)(iVar2 + 0xc4))(param_1);
  if (iVar1 != 0) {
    iVar2 = (**(code **)(iVar2 + 0x6c))(param_1,param_1);
    return iVar2;
  }
  if (*(int *)&this->field_0x28 == -1) {
    iVar1 = RGE_Player::computerPlayer(*(RGE_Player **)(*(int *)&this->field_0x4 + 0xc));
    if (iVar1 != 0) {
      fVar3 = (float10)(**(code **)(**(int **)&this->field_0x4 + 0x10c))(param_1);
      iVar2 = (**(code **)(iVar2 + 0x94))(param_1,(float)fVar3);
      return iVar2;
    }
  }
  return 0;
}

// --------------------------------------------------

// Function: retryableOrder
// Address: 00505a10
int __thiscall TribePriestUnitAIModule::retryableOrder(TribePriestUnitAIModule *this,int param_1)
{
  if ((param_1 != 0x2c0) && (param_1 != 0x2bf)) {
    return 0;
  }
  return 1;
}

// --------------------------------------------------

// Function: canConvert
// Address: 00505a30
int __thiscall TribePriestUnitAIModule::canConvert(TribePriestUnitAIModule *this,int param_1)
{
  short sVar1;
  short sVar2;
  RGE_Static_Object *pRVar3;
  
  if (_DAT_005758d4 <= *(float *)(*(int *)&this->field_0x4 + 0x44)) {
    pRVar3 = RGE_Game_World::object
                       (*(RGE_Game_World **)(*(int *)(*(int *)&this->field_0x4 + 0xc) + 0x3c),
                        param_1);
    if (pRVar3 != (RGE_Static_Object *)0x0) {
      sVar1 = pRVar3->master_obj->object_group;
      sVar2 = pRVar3->master_obj->id;
      if ((((((sVar2 != 0x6d) && (sVar1 != 0x1b)) && (sVar2 != 0x9f)) &&
           ((sVar2 != 0x114 && (sVar2 != 0x9e)))) && ((sVar2 != 0xa3 && (sVar1 != 0x1e)))) &&
         (((sVar1 != 0x12 ||
           (_DAT_005758c4 <
            *(float *)(*(int *)(*(int *)(*(int *)&this->field_0x4 + 0xc) + 0x50) + 0x6c))) &&
          ((sVar1 != 3 ||
           (_DAT_005758c4 <
            *(float *)(*(int *)(*(int *)(*(int *)&this->field_0x4 + 0xc) + 0x50) + 0x70))))))) {
        return 1;
      }
    }
  }
  return 0;
}

// --------------------------------------------------

// Function: canAttackUnit
// Address: 00505ae0
int __thiscall
TribePriestUnitAIModule::canAttackUnit(TribePriestUnitAIModule *this,RGE_Static_Object *param_1)
{
  int iVar1;
  
  if (param_1 != (RGE_Static_Object *)0x0) {
    iVar1 = (**(code **)(*(int *)this + 0xc4))(param_1->id);
    return iVar1;
  }
  return 0;
}

// --------------------------------------------------

// Function: bestUnitToHeal
// Address: 00505b00
int __thiscall
TribePriestUnitAIModule::bestUnitToHeal(TribePriestUnitAIModule *this,int param_1,float *param_2)
{
  int *piVar1;
  float fVar2;
  float fVar3;
  int iVar4;
  RGE_Static_Object *pRVar5;
  int iVar6;
  int allyToHealID;
  int maxLimit;
  float allyNeed;
  int i;
  int a;
  int iStack_c;
  int iStack_8;
  
  (**(code **)(*(int *)this + 0x20))();
  iVar4 = -1;
  maxLimit = -1;
  i = 0;
  allyNeed = 2.8026e-45;
  if (*(short *)(*(int *)(*(int *)&this->field_0x4 + 0xc) + 0x4a) == 0) {
    allyNeed = 5.60519e-45;
  }
  iStack_c = 1;
  if (allyNeed != 0.0) {
    iStack_8 = 0;
    do {
      a = 0;
      if (0 < *(int *)((int)&DAT_0087d7cc + iStack_8)) {
        piVar1 = (int *)((int)&DAT_0087d7e4 + iStack_8);
        do {
          iVar4 = a * 8;
          if ((((((*(int *)(iVar4 + *piVar1) != *(int *)(*(int *)&this->field_0x4 + 4)) &&
                 (pRVar5 = UnitAIModule::lookupObject
                                     ((UnitAIModule *)this,*(int *)(iVar4 + *piVar1)),
                 pRVar5 != (RGE_Static_Object *)0x0)) && (pRVar5->master_obj->object_group != 3)) &&
               (((pRVar5->hp < (float)(int)pRVar5->master_obj->hp && (pRVar5->object_state < 3)) &&
                ((param_1 != 0 || (*(byte *)(iVar4 + 4 + *piVar1) < 5)))))) &&
              ((*(short *)((*(int **)&this->field_0x4)[3] + 0x4a) != 0 ||
               (*(byte *)(iVar4 + 4 + *piVar1) < 3)))) &&
             (iVar6 = (**(code **)(**(int **)&this->field_0x4 + 0x194))
                                (*(undefined4 *)(iVar4 + *piVar1),0x3f800000,0,0,0xffffffff,
                                 0xffffffff), iVar6 != 0)) {
            fVar3 = (float)*(byte *)(iVar4 + 4 + *piVar1);
            fVar2 = (float)(int)pRVar5->master_obj->hp - pRVar5->hp / fVar3;
            if (((maxLimit == -1) || (fVar2 < (float)i)) &&
               (maxLimit = pRVar5->id, i = (int)fVar2, param_2 != (float *)0x0)) {
              *param_2 = fVar3;
            }
          }
          a = a + 1;
          iVar4 = maxLimit;
        } while (a < *(int *)((int)&DAT_0087d7cc + iStack_8));
      }
      if (iVar4 != -1) {
        return iVar4;
      }
      iStack_c = iStack_c + 1;
      iStack_8 = iStack_8 + 4;
    } while (iStack_c <= (int)allyNeed);
  }
  return -1;
}

// --------------------------------------------------

// Function: bestUnitToConvert
// Address: 00505cc0
int __thiscall
TribePriestUnitAIModule::bestUnitToConvert(TribePriestUnitAIModule *this,float *param_1)
{
  int iVar1;
  float fVar2;
  float fVar3;
  int iVar4;
  RGE_Static_Object *pRVar5;
  long lVar6;
  float targetValue;
  int i;
  int iStack_8;
  
  (**(code **)(*(int *)this + 0x20))();
  lVar6 = -1;
  i = 0;
  iStack_8 = 0;
  if (0 < DAT_0087d7d8) {
    do {
      iVar1 = iStack_8 * 8;
      iVar4 = (**(code **)(**(int **)(*(int *)&this->field_0x4 + 0xc) + 0x18))
                        (*(undefined1 *)(DAT_0087d7f0 + 5 + iVar1));
      if ((((iVar4 != 0) &&
           (pRVar5 = UnitAIModule::lookupObject((UnitAIModule *)this,*(int *)(DAT_0087d7f0 + iVar1))
           , pRVar5 != (RGE_Static_Object *)0x0)) && (pRVar5->object_state < 3)) &&
         (iVar4 = (**(code **)(*(int *)this + 0xc4))(pRVar5->id), iVar4 != 0)) {
        fVar2 = (float)*(byte *)(DAT_0087d7f0 + 4 + iVar1);
        if (fVar2 < _DAT_005758bc) {
          fVar2 = _DAT_005758bc;
        }
        fVar3 = (float)(int)pRVar5->master_obj->hp / fVar2;
        if (((lVar6 == -1) || ((float)i < fVar3)) &&
           (lVar6 = pRVar5->id, i = (int)fVar3, param_1 != (float *)0x0)) {
          *param_1 = fVar2;
        }
      }
      iStack_8 = iStack_8 + 1;
    } while (iStack_8 < DAT_0087d7d8);
  }
  return lVar6;
}

// --------------------------------------------------

// Function: processNotify
// Address: 00505dd0
// [HELPER] s_C__msdev_work_age1_x1_taiuaimd_c: "C:\msdev\work\age1_x1\taiuaimd.cpp"
// [HELPER] s___d_call_stopObject__s__d_: "#%d call stopObject %s %d\n"
int __thiscall
TribePriestUnitAIModule::processNotify
          (TribePriestUnitAIModule *this,NotifyEvent *param_1,ulong param_2)
{
  uchar uVar1;
  int iVar2;
  RGE_Static_Object *pRVar3;
  int iVar4;
  undefined4 uVar5;
  
  switch(param_1->mType) {
  case 0x1f9:
  case 0x1fb:
  case 0x202:
    break;
  case 0x1fc:
    pRVar3 = UnitAIModule::lookupObject((UnitAIModule *)this,*(int *)&this->field_0x34);
    if (pRVar3 != (RGE_Static_Object *)0x0) {
      iVar4 = __ftol();
      iVar2 = __ftol();
      uVar1 = UnitAIModule::visibleStatus
                        ((UnitAIModule *)this,
                         *(RGE_Visible_Map **)(*(int *)(*(int *)&this->field_0x4 + 0xc) + 0x38),
                         iVar2,iVar4);
      if (uVar1 == '\x0f') {
        return 2;
      }
    }
    UnitAIModule::removeCurrentTarget((UnitAIModule *)this);
    if (actionFile != (_iobuf *)0x0) {
      if (*(int *)&this->field_0x4 == 0) {
        uVar5 = 0xffffffff;
      }
      else {
        uVar5 = *(undefined4 *)(*(int *)&this->field_0x4 + 4);
      }
      fprintf(actionFile,s___d_call_stopObject__s__d_,uVar5,s_C__msdev_work_age1_x1_taiuaimd_c,0x68f
             );
    }
    iVar4 = *(int *)this;
    (**(code **)(iVar4 + 0x58))(1);
    (**(code **)(iVar4 + 0x1c))(param_1);
  default:
    iVar4 = UnitAIModule::processNotify((UnitAIModule *)this,param_1,param_2);
    return iVar4;
  }
  iVar4 = RGE_Player::computerPlayer(*(RGE_Player **)(*(int *)&this->field_0x4 + 0xc));
  if ((iVar4 == 0) && (*(int *)&this->field_0x30 == 0x25c)) {
    UnitAIModule::removeCurrentTarget((UnitAIModule *)this);
    if (actionFile != (_iobuf *)0x0) {
      if (*(int *)&this->field_0x4 == 0) {
        uVar5 = 0xffffffff;
      }
      else {
        uVar5 = *(undefined4 *)(*(int *)&this->field_0x4 + 4);
      }
      fprintf(actionFile,s___d_call_stopObject__s__d_,uVar5,s_C__msdev_work_age1_x1_taiuaimd_c,0x63b
             );
    }
    iVar4 = *(int *)this;
    uVar5 = 1;
  }
  else {
    if (*(int *)&this->field_0x30 == 0x25c) {
      iVar4 = *(int *)this;
      iVar2 = (**(code **)(iVar4 + 0xe4))(0);
      if ((iVar2 != -1) && (iVar4 = (**(code **)(iVar4 + 0x6c))(iVar2,1), iVar4 == 1)) {
        return 3;
      }
    }
    else if (*(int *)&this->field_0x30 == 0x25b) {
      iVar4 = *(int *)this;
      iVar2 = (**(code **)(iVar4 + 0xe0))(0,0);
      if ((iVar2 != -1) && (iVar4 = (**(code **)(iVar4 + 0x70))(iVar2,1), iVar4 == 1)) {
        return 3;
      }
    }
    UnitAIModule::removeCurrentTarget((UnitAIModule *)this);
    if (actionFile != (_iobuf *)0x0) {
      if (*(int *)&this->field_0x4 == 0) {
        uVar5 = 0xffffffff;
      }
      else {
        uVar5 = *(undefined4 *)(*(int *)&this->field_0x4 + 4);
      }
      fprintf(actionFile,s___d_call_stopObject__s__d_,uVar5,s_C__msdev_work_age1_x1_taiuaimd_c,0x675
             );
    }
    iVar4 = *(int *)this;
    uVar5 = 0;
  }
  (**(code **)(iVar4 + 0x58))(uVar5);
  (**(code **)(iVar4 + 0x1c))(param_1);
  return 2;
}

// --------------------------------------------------

// Function: processIdle
// Address: 00505fd0
// [HELPER] s_C__msdev_work_age1_x1_taiuaimd_c: "C:\msdev\work\age1_x1\taiuaimd.cpp"
int __thiscall TribePriestUnitAIModule::processIdle(TribePriestUnitAIModule *this,int param_1)
{
  int *piVar1;
  int iVar2;
  int iVar3;
  RGE_Static_Object *pRVar4;
  float10 fVar5;
  float fVar6;
  float fVar7;
  float fVar8;
  float yDiff;
  float xDiff;
  float distanceDiff;
  undefined1 local_4 [4];
  
  iVar2 = RGE_Player::computerPlayer(*(RGE_Player **)(*(int *)&this->field_0x4 + 0xc));
  if (iVar2 != 0) {
    iVar3 = UnitAIModule::processIdle((UnitAIModule *)this,1);
    iVar2 = DAT_0087d7d8;
    if (iVar3 == 6) {
      return 6;
    }
    iVar3 = debug_rand(s_C__msdev_work_age1_x1_taiuaimd_c,0x6ac);
    if ((0 < iVar2) && (iVar2 < iVar3 % (iVar2 + 2))) {
      iVar2 = *(int *)this;
      iVar3 = (**(code **)(iVar2 + 0xe0))(1,local_4);
      if (iVar3 != -1) {
        (**(code **)(iVar2 + 0x70))(iVar3,0);
        return 6;
      }
    }
    iVar2 = *(int *)this;
    iVar3 = (**(code **)(iVar2 + 0x40))(0xffffffff,2,0xffffffff,0xffffffff,0);
    if (iVar3 != -1) {
      pRVar4 = RGE_Game_World::object
                         (*(RGE_Game_World **)(*(int *)(*(int *)&this->field_0x4 + 0xc) + 0x3c),
                          iVar3);
      if (pRVar4 != (RGE_Static_Object *)0x0) {
        piVar1 = *(int **)&this->field_0x4;
        fVar7 = pRVar4->world_x - (float)piVar1[0xe];
        fVar6 = pRVar4->world_y - (float)piVar1[0xf];
        fVar8 = SQRT(fVar6 * fVar6 + fVar7 * fVar7);
        fVar5 = (float10)(**(code **)(*piVar1 + 0x10c))();
        fVar5 = fVar5 - (float10)fVar8;
        if (fVar5 <= (float10)_DAT_005758c4) {
          return 5;
        }
        iVar3 = *(int *)&this->field_0x4;
        (**(code **)(iVar2 + 0x9c))
                  ((float)(-(((float10)fVar7 / (float10)fVar8) * fVar5) +
                          (float10)*(float *)(iVar3 + 0x38)),
                   (float)(-(((float10)fVar6 / (float10)fVar8) * fVar5) +
                          (float10)*(float *)(iVar3 + 0x3c)),*(undefined4 *)(iVar3 + 0x40),1);
        return 6;
      }
    }
  }
  return 5;
}

// --------------------------------------------------

// Function: processMisc
// Address: 00506140
// [HELPER] s_C__msdev_work_age1_x1_taiuaimd_c: "C:\msdev\work\age1_x1\taiuaimd.cpp"
// [HELPER] s___d_call_stopObject__s__d_: "#%d call stopObject %s %d\n"
int __thiscall TribePriestUnitAIModule::processMisc(TribePriestUnitAIModule *this)
{
  uchar uVar1;
  int iVar2;
  RGE_Action *pRVar3;
  int iVar4;
  undefined4 uVar5;
  
  iVar2 = RGE_Player::computerPlayer(*(RGE_Player **)(*(int *)&this->field_0x4 + 0xc));
  if (((iVar2 == 1) && (iVar2 = *(int *)&this->field_0x4, _DAT_005758d4 <= *(float *)(iVar2 + 0x44))
      ) && ((uVar1 = RGE_Action_List::have_action(*(RGE_Action_List **)(iVar2 + 0x184)),
            uVar1 != '\x01' ||
            (pRVar3 = RGE_Action_List::get_action(*(RGE_Action_List **)(iVar2 + 0x184)),
            pRVar3->state != '\a')))) {
    iVar2 = *(int *)this;
    iVar4 = (**(code **)(iVar2 + 0x30))(1,1,0);
    if ((iVar4 != -1) && (*(int *)&this->field_0x34 != iVar4)) {
      if (*(int *)&this->field_0x28 != -1) {
        (**(code **)(iVar2 + 0x10))
                  (*(undefined4 *)(*(int *)&this->field_0x4 + 4),*(int *)&this->field_0x28,
                   *(int *)&this->field_0x34,0xffffffff,*(undefined4 *)&this->field_0x3c,
                   *(undefined4 *)&this->field_0x40,*(undefined4 *)&this->field_0x44,
                   *(undefined4 *)&this->field_0x48,0,0,*(undefined4 *)&this->field_0x2c);
        if (actionFile != (_iobuf *)0x0) {
          if (*(int *)&this->field_0x4 == 0) {
            uVar5 = 0xffffffff;
          }
          else {
            uVar5 = *(undefined4 *)(*(int *)&this->field_0x4 + 4);
          }
          fprintf(actionFile,s___d_call_stopObject__s__d_,uVar5,s_C__msdev_work_age1_x1_taiuaimd_c,
                  0x6f8);
        }
        (**(code **)(iVar2 + 0x58))(1);
      }
      iVar2 = (**(code **)(iVar2 + 0x5c))(iVar4,1);
      if (iVar2 == 1) {
        return 10;
      }
    }
  }
  return 9;
}

// --------------------------------------------------

